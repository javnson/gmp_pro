/**
 * @file fir_filter.h
 * @author Javnson (javnson@zju.edu.cn)
 * @brief Provides a generic Finite Impulse Response (FIR) filter module.
 * @version 1.0
 * @date 2025-08-09
 *
 * @copyright Copyright GMP(c) 2024
 *
 */

#ifndef _FIR_FILTER_H_
#define _FIR_FILTER_H_

#include <ctl/math_block/gmp_math.h>
#include <stdint.h>

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

/**
 * @defgroup fir_filter FIR Filter
 * @brief A generic FIR filter for custom coefficients.
 * @details This file implements a generic FIR filter, suitable for use with
 * coefficients designed in external tools like MATLAB. The filter is implemented
 * using a circular buffer for efficient real-time processing.
 * The difference equation is:
 * @f[ y(n) = \sum_{k=0}^{N-1} b_k x(n-k) @f]
 * where N is the number of taps (order), b_k are the filter coefficients,
 * and x are the input samples. * @{
 */

/*---------------------------------------------------------------------------*/
/* Generic FIR Filter                                                        */
/*---------------------------------------------------------------------------*/

/**
 * @brief Data structure for the generic FIR filter.
 * @details This structure holds the configuration and state for a direct-form
 * FIR filter.
 * The difference equation is:
 * @f[ y(n) = \sum_{k=0}^{N-1} b_k x(n-k) @f]
 * where N is the number of taps (order), b_k are the filter coefficients,
 * and x are the input samples.
 */
typedef struct _tag_fir_filter_t
{
    uint32_t order;        //!< The order of the filter (number of taps, N).
    const ctrl_gt* coeffs; //!< Pointer to the array of filter coefficients (b0, b1, ...).

    ctrl_gt* buffer;       //!< Pointer to the circular buffer for past inputs x(n-k).
    uint32_t buffer_index; //!< Current index for the circular buffer.

    ctrl_gt output; //!< The last calculated filter output, y(n).
} ctl_fir_filter_t;

/**
 * @brief Initializes the generic FIR filter.
 * @details This function allocates memory for the filter's internal state buffer.
 * The user is responsible for calling ctl_destroy_fir_filter to free this memory.
 * The coefficient array `coeffs` is NOT copied; only a pointer is stored. Therefore,
 * the coefficient array must remain valid for the lifetime of the filter object.
 * @param[out] fir Pointer to the FIR filter instance.
 * @param[in] order The number of filter taps (e.g., the length of the coefficient array from MATLAB).
 * @param[in] coeffs Pointer to the array of filter coefficients. These should be generated by a tool like MATLAB.
 * @return fast_gt Returns 1 on success (memory allocated), 0 on failure.
 */
fast_gt ctl_init_fir_filter(ctl_fir_filter_t* fir, uint32_t order, const ctrl_gt* coeffs);

/**
 * @brief Frees the memory allocated for the FIR filter's buffer.
 * @param[in,out] fir Pointer to the FIR filter instance.
 */
GMP_STATIC_INLINE void ctl_destroy_fir_filter(ctl_fir_filter_t* fir)
{
    if (fir->buffer != NULL)
    {
        free(fir->buffer);
        fir->buffer = NULL;
    }
}

/**
 * @brief Clears the internal state buffer of the FIR filter.
 * @param[out] fir Pointer to the FIR filter instance.
 */
GMP_STATIC_INLINE void ctl_clear_fir_filter(ctl_fir_filter_t* fir)
{
    if (fir->buffer != NULL)
    {
        for (uint32_t i = 0; i < fir->order; i++)
        {
            fir->buffer[i] = 0.0f;
        }
    }
    fir->output = 0.0f;
    fir->buffer_index = 0;
}

/**
 * @brief Executes one step of the FIR filter calculation (convolution).
 * @param[in,out] fir Pointer to the FIR filter instance.
 * @param[in] input The new input sample, x(n).
 * @return ctrl_gt The calculated filter output, y(n).
 */
GMP_STATIC_INLINE ctrl_gt ctl_step_fir_filter(ctl_fir_filter_t* fir, ctrl_gt input)
{
    // 更新循环缓冲区
    // 将最新的输入样本存入循环缓冲区的当前位置。
    // 这种方法避免了在每个采样周期都移动整个数组，效率极高。
    fir->buffer[fir->buffer_index] = input;

    // 执行卷积运算
    // 输出 y(n) 是系数向量 b 和输入状态向量 x 的点积。
    // 遍历系数，并从循环缓冲区中以正确的顺序取出对应的历史输入样本进行乘加运算。
    fir->output = 0.0f;
    uint32_t j = fir->buffer_index;
    for (uint32_t i = 0; i < fir->order; i++)
    {
        // fir->coeffs[i] 对应 b_i
        // fir->buffer[j] 对应 x(n-i)
        fir->output += fir->coeffs[i] * fir->buffer[j];

        // 在循环缓冲区中回溯索引
        if (j == 0)
        {
            j = fir->order - 1;
        }
        else
        {
            j--;
        }
    }

    // 更新缓冲区index
    // 为下一次采样准备，将索引前移。如果到达缓冲区末端，则绕回到开头。
    fir->buffer_index++;
    if (fir->buffer_index >= fir->order)
    {
        fir->buffer_index = 0;
    }

    return fir->output;
}

/**
 * @}
 */ // end of fir_filter group

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _FIR_FILTER_H_
