/**
 * @file three_phase_dc_ac.h
 * @author Javnson (javnson@zju.edu.cn)
 * @brief Header-only library for a preset three-phase DC/AC inverter controller.
 * @version 1.0
 * @date 2025-08-05
 *
 * @copyright Copyright GMP(c) 2025
 */

/** 
 * @defgroup CTL_TOPOLOGY_INV_H_API Three-Phase Inverter Topology API (Header)
 * @{
 * @ingroup CTL_DP_LIB
 * @brief Defines the data structures, control flags, and function interfaces for a
 * comprehensive three-phase inverter, including harmonic compensation, droop control,
 * and multiple operating modes.
 */

#ifndef _FILE_THREE_PHASE_DC_AC_H_
#define _FILE_THREE_PHASE_DC_AC_H_

#ifdef __cplusplus
extern "C"
{
#endif // __cplusplus

#include <ctl/math_block/coordinate/coord_trans.h>

#include <ctl/component/intrinsic/basic/saturation.h>
#include <ctl/component/intrinsic/continuous/continuous_pid.h>
#include <ctl/component/intrinsic/discrete/discrete_filter.h>
#include <ctl/component/intrinsic/discrete/proportional_resonant.h>
#include <ctl/component/intrinsic/discrete/signal_generator.h>

#include <ctl/component/digital_power/three_phase/pll.h>

// --- Compilation-time Configuration Macros ---

#ifndef CURRENT_SAMPLE_PHASE_MODE
/**
 * @brief Configures the current sampling method.
 * - **3**: Sample all three phase currents (Ia, Ib, Ic).
 * - **2**: Sample two phase currents (Ia, Ib), and calculate the third.
 */
#define CURRENT_SAMPLE_PHASE_MODE (3)
#endif // CURRENT_SAMPLE_PHASE_MODE

#ifndef VOLTAGE_SAMPLE_PHASE_MODE
/**
 * @brief Configures the voltage sampling method.
 * - **3**: Sample all three phase voltages (Va, Vb, Vc).
 * - **2**: Sample two phase voltages (Va, Vb), and calculate the third.
 * - **1**: Sample two line-to-line voltages (Vab, Vbc).
 */
#define VOLTAGE_SAMPLE_PHASE_MODE (1)
#endif // VOLTAGE_SAMPLE_PHASE_MODE

/**
 * @brief Main data structure for the three-phase inverter controller.
 */
typedef struct _tag_inv_ctrl_type
{
    //
    // --- Input Ports (ADC Interfaces) ---
    //
    adc_ift* adc_udc;     //!< DC Bus voltage.
    adc_ift* adc_idc;     //!< DC Bus current.
    adc_ift* adc_iabc[3]; //!< Array of pointers to phase current ADCs {Ia, Ib, Ic}.
    adc_ift* adc_vabc[3]; //!< Array of pointers to phase voltage ADCs {Va, Vb, Vc}.

    //
    // --- Output Ports ---
    //
    ctl_vector3_t pwm_out_pu; //!< Final PWM duty cycles {A, B, C} in per-unit format.

    //
    // --- Feed-forward & Parameters ---
    //
    ctrl_gt omega_L;          //!< Feed-forward decoupling term: `2*pi*f*L` in per-unit.
    ctrl_gt kp_droop;         //!< Active power droop coefficient (P-f).
    ctrl_gt kq_droop;         //!< Reactive power droop coefficient (Q-V).
    ctrl_gt rg_slope_default; //!< Default slope for the ramp generator.

    //
    // --- Setpoints & Intermediate Variables (Read/Write) ---
    //
    ctl_vector2_t vdq_set;     //!< R/W: Voltage command in d-q frame (for voltage mode).
    ctrl_gt v_droop_ref;       //!< R/W: Droop control voltage reference.
    ctrl_gt rg_freq_pu;        //!< R/W: Ramp generator frequency in per-unit (for freerun mode).
    ctl_vector2_t idq_set;     //!< R/W: Current command in d-q frame (for current mode).
    ctl_vector2_t idq_ff;      //!< R/W: Current feed-forward term in d-q frame.
    ctl_vector2_t vdq_pos_out; //!< R/W: Output of positive-sequence current controller.

    //
    // --- Measurement & Internal State Variables (Read-Only) ---
    //
    ctl_vector3_t iabc;          //!< RO: Filtered three-phase currents.
    ctl_vector3_t iab0;          //!< RO: Clarke transformed currents {alpha, beta, zero}.
    ctl_vector2_t idq;           //!< RO: Park transformed currents {d, q}.
    ctl_vector3_t vabc;          //!< RO: Filtered three-phase voltages.
    ctl_vector3_t vab0;          //!< RO: Clarke transformed voltages {alpha, beta, zero}.
    ctl_vector2_t vdq;           //!< RO: Park transformed voltages {d, q}.
    ctl_vector2_t idq_droop_set; //!< RO: Current command generated by droop controller.
    ctl_vector2_t vab_pos;       //!< RO: Positive-sequence modulation voltage in alpha-beta frame.
    ctl_vector2_t vab_out;       //!< RO: Total modulation voltage in alpha-beta frame.
    ctl_vector2_t idq_net_set;   //!< RO: Negative-sequence current command from voltage loop.
    ctl_vector2_t vdq_neg;       //!< RO: Measured negative-sequence voltage in d-q frame.
    ctl_vector2_t idq_neg;       //!< RO: Measured negative-sequence current in d-q frame.
    ctl_vector2_t vdq_neg_out;   //!< RO: Output of negative-sequence current controller.
    ctl_vector2_t vab_neg;       //!< RO: Negative-sequence modulation voltage in alpha-beta frame.
    ctl_vector2_t vab_harm;      //!< RO: Harmonic compensation voltage in alpha-beta frame.
    ctrl_gt angle;               //!< RO: Estimated grid angle.
    ctl_vector2_t phasor;        //!< RO: Phasor {cos, sin} corresponding to the grid angle.
    ctrl_gt v0_set;              //!< RO: Zero-sequence voltage command.
    ctl_vector3_t abc_out;       //!< RO: Final three-phase modulation signals before scaling.

    //
    // --- Controller Objects ---
    //
    ctl_low_pass_filter_t lpf_udc;     //!< LPF for DC voltage measurement.
    ctl_low_pass_filter_t lpf_idc;     //!< LPF for DC current measurement.
    ctl_low_pass_filter_t lpf_iabc[3]; //!< LPFs for phase current measurements.
    ctl_low_pass_filter_t lpf_vabc[3]; //!< LPFs for phase voltage measurements.

    three_phase_pll_t pll;   //!< Three-phase PLL for grid synchronization.
    ctl_ramp_generator_t rg; //!< Ramp generator for open-loop/freerun operation.

    ctl_pid_t voltage_ctrl[2];     //!< PI controllers for d-q voltage loops.
    ctl_pid_t current_ctrl[2];     //!< PI controllers for d-q current loops.
    ctl_pid_t neg_voltage_ctrl[2]; //!< PI controllers for negative-sequence d-q voltage loops.
    ctl_pid_t neg_current_ctrl[2]; //!< PI controllers for negative-sequence d-q current loops.
    ctl_pid_t zero_pid;            //!< PI controller for zero-sequence current loop.

    ctl_saturation_t idq_droop_sat[2]; //!< Saturation blocks for droop controller outputs.

    qr_ctrl_t harm_qr_5[2]; //!< QR controllers for 5th harmonic compensation (alpha, beta).
    qr_ctrl_t harm_qr_7[2]; //!< QR controllers for 7th harmonic compensation (alpha, beta).
    qr_ctrl_t zero_qr_3;    //!< QR controller for 3rd zero-sequence harmonic.
    qr_ctrl_t zero_qr_9;    //!< QR controller for 9th zero-sequence harmonic.

    //
    // --- Control Flags ---
    //
    fast_gt flag_enable_system;                //!< Master enable for the entire controller.
    fast_gt flag_enable_voltage_ctrl;          //!< Enables the outer voltage control loop.
    fast_gt flag_enable_droop;                 //!< Enables droop control.
    fast_gt flag_enable_current_ctrl;          //!< Enables the inner current control loop.
    fast_gt flag_enable_decouple_lf;           //!< Enables inductor decoupling feed-forward.
    fast_gt flag_enable_harm_ctrl;             //!< Enables the additional harmonic compensators.
    fast_gt flag_enable_negative_voltage_ctrl; //!< Enables the negative-sequence voltage loop.
    fast_gt flag_enable_negative_current_ctrl; //!< Enables the negative-sequence current loop.
    fast_gt flag_enable_zero_current_ctrl;     //!< Enables the zero-sequence current loop.
    fast_gt flag_enable_pll;                   //!< Enables the three-phase PLL.
    fast_gt flag_enable_freerun;               //!< 1 to use ramp generator angle, 0 to use PLL angle.

} inv_ctrl_t;

/**
 * @brief Initialization parameters for the three-phase inverter controller.
 */
typedef struct _tag_three_phase_inv_init_type
{
    // --- General Parameters ---
    parameter_gt v_base;    //!< Base voltage for per-unit conversion (V).
    parameter_gt i_base;    //!< Base current for per-unit conversion (A).
    parameter_gt freq_base; //!< Nominal grid frequency (e.g., 50 or 60 Hz).
    parameter_gt Lf;        //!< Grid-side filter inductance (H).
    parameter_gt fs;        //!< Controller execution frequency (sampling frequency) in Hz.
    parameter_gt adc_fc;    //!< Cutoff frequency for all ADC input filters (Hz).

    // --- Positive-Sequence Controller Gains ---
    parameter_gt kp_id_ctrl;  //!< d-axis current loop: Proportional gain.
    parameter_gt Ti_id_ctrl;  //!< d-axis current loop: Integral time (s).
    parameter_gt kp_iq_ctrl;  //!< q-axis current loop: Proportional gain.
    parameter_gt Ti_iq_ctrl;  //!< q-axis current loop: Integral time (s).
    parameter_gt kp_vd_ctrl;  //!< d-axis voltage loop: Proportional gain.
    parameter_gt Ti_vd_ctrl;  //!< d-axis voltage loop: Integral time (s).
    parameter_gt kp_vq_ctrl;  //!< q-axis voltage loop: Proportional gain.
    parameter_gt Ti_vq_ctrl;  //!< q-axis voltage loop: Integral time (s).
    parameter_gt kp_pll_ctrl; //!< PLL loop: Proportional gain.
    parameter_gt Ti_pll_ctrl; //!< PLL loop: Integral time (s).

    // --- Negative-Sequence Controller Gains ---
    parameter_gt kp_vdn_ctrl; //!< Negative d-axis voltage loop: Proportional gain.
    parameter_gt Ti_vdn_ctrl; //!< Negative d-axis voltage loop: Integral time (s).
    parameter_gt kp_vqn_ctrl; //!< Negative q-axis voltage loop: Proportional gain.
    parameter_gt Ti_vqn_ctrl; //!< Negative q-axis voltage loop: Integral time (s).
    parameter_gt kp_idn_ctrl; //!< Negative d-axis current loop: Proportional gain.
    parameter_gt Ti_idn_ctrl; //!< Negative d-axis current loop: Integral time (s).
    parameter_gt kp_iqn_ctrl; //!< Negative q-axis current loop: Proportional gain.
    parameter_gt Ti_iqn_ctrl; //!< Negative q-axis current loop: Integral time (s).

    // --- Harmonic Controller Gains ---
    parameter_gt harm_ctrl_kr_5;       //!< 5th harmonic (QR): Resonant gain.
    parameter_gt harm_ctrl_cut_freq_5; //!< 5th harmonic (QR): Cutoff frequency (Hz).
    parameter_gt harm_ctrl_kr_7;       //!< 7th harmonic (QR): Resonant gain.
    parameter_gt harm_ctrl_cut_freq_7; //!< 7th harmonic (QR): Cutoff frequency (Hz).

    // --- Droop Control Parameters ---
    parameter_gt kp_droop;     //!< Active power (P-f) droop coefficient.
    parameter_gt kq_droop;     //!< Reactive power (Q-V) droop coefficient.
    parameter_gt id_lim_droop; //!< Droop control d-axis current limit.
    parameter_gt iq_lim_droop; //!< Droop control q-axis current limit.

    // --- Zero-Sequence Controller Gains ---
    parameter_gt zero_ctrl_kp;         //!< Zero-sequence PI: Proportional gain.
    parameter_gt zero_ctrl_Ti;         //!< Zero-sequence PI: Integral time (s).
    parameter_gt zero_ctrl_kr_3;       //!< 3rd zero-sequence harmonic (QR): Resonant gain.
    parameter_gt zero_ctrl_cut_freq_3; //!< 3rd zero-sequence harmonic (QR): Cutoff frequency (Hz).
    parameter_gt zero_ctrl_kr_9;       //!< 9th zero-sequence harmonic (QR): Resonant gain.
    parameter_gt zero_ctrl_cut_freq_9; //!< 9th zero-sequence harmonic (QR): Cutoff frequency (Hz).

} three_phase_inv_init_t;

// --- Function Declarations & Inline Implementations ---

// Forward declarations for functions defined in the corresponding .c file
void ctl_upgrade_three_phase_inv(inv_ctrl_t* inv, three_phase_inv_init_t* init);
void ctl_init_three_phase_inv(inv_ctrl_t* inv, three_phase_inv_init_t* init);
void ctl_attach_three_phase_inv(inv_ctrl_t* inv, adc_ift* adc_udc, adc_ift* adc_idc, adc_ift* adc_ia, adc_ift* adc_ib,
                                adc_ift* adc_ic, adc_ift* adc_ua, adc_ift* adc_ub, adc_ift* adc_uc);

/**
 * @brief Executes one step of the three-phase inverter control algorithm.
 * @ingroup CTL_TOPOLOGY_INV_H_API
 * @param[out] ctrl Pointer to the `inv_ctrl_t` structure.
 */
GMP_STATIC_INLINE void ctl_step_inv_ctrl(inv_ctrl_t* ctrl)
{
    // --- 1. Input Filtering and Coordinate Transformation ---
    ctl_step_lowpass_filter(&ctrl->lpf_udc, ctrl->adc_udc->value);
    ctl_step_lowpass_filter(&ctrl->lpf_idc, ctrl->adc_idc->value);

#if CURRENT_SAMPLE_PHASE_MODE == 3
    for (size_gt i = 0; i < 3; ++i)
        ctrl->iabc.dat[i] = ctl_step_lowpass_filter(&ctrl->lpf_iabc[i], ctrl->adc_iabc[i]->value);
    ctl_ct_clarke(&ctrl->iabc, &ctrl->iab0);
#elif CURRENT_SAMPLE_PHASE_MODE == 2
    for (size_gt i = 0; i < 2; ++i)
        ctrl->iabc.dat[i] = ctl_step_lowpass_filter(&ctrl->lpf_iabc[i], ctrl->adc_iabc[i]->value);
    ctrl->iabc.dat[phase_C] = 0;
    ctl_ct_clarke_2ph((ctl_vector2_t*)&ctrl->iabc, (ctl_vector2_t*)&ctrl->iab0);
    ctrl->iab0.dat[phase_0] = 0;
#endif

#if VOLTAGE_SAMPLE_PHASE_MODE == 3
    for (size_gt i = 0; i < 3; ++i)
        ctrl->vabc.dat[i] = ctl_step_lowpass_filter(&ctrl->lpf_vabc[i], ctrl->adc_vabc[i]->value);
    ctl_ct_clarke(&ctrl->vabc, &ctrl->vab0);
#elif VOLTAGE_SAMPLE_PHASE_MODE == 2
    for (size_gt i = 0; i < 2; ++i)
        ctrl->vabc.dat[i] = ctl_step_lowpass_filter(&ctrl->lpf_vabc[i], ctrl->adc_vabc[i]->value);
    ctrl->vabc.dat[phase_C] = 0;
    ctl_ct_clarke_2ph((ctl_vector2_t*)&ctrl->vabc, (ctl_vector2_t*)&ctrl->vab0);
    ctrl->vab0.dat[phase_0] = 0;
#elif VOLTAGE_SAMPLE_PHASE_MODE == 1
    for (size_gt i = 0; i < 2; ++i)
        ctrl->vabc.dat[i] = ctl_step_lowpass_filter(&ctrl->lpf_vabc[i], ctrl->adc_vabc[i]->value);
    ctrl->vabc.dat[phase_C] = 0;
    ctl_ct_clarke_from_line((ctl_vector2_t*)&ctrl->vabc, (ctl_vector2_t*)&ctrl->vab0);
    ctrl->vab0.dat[phase_0] = 0;
#endif

    // --- 2. Grid Synchronization (PLL) ---
    if (ctrl->flag_enable_pll)
    {
        ctl_step_pll_3ph(&ctrl->pll, ctrl->vab0.dat[phase_alpha], ctrl->vab0.dat[phase_beta]);
    }

    // --- 3. Main Control Logic ---
    if (ctrl->flag_enable_system)
    {
        // --- 3a. Angle and Phasor Generation ---
        if (ctrl->flag_enable_freerun)
        {
            // CHECK HERE!
            ctl_set_ramp_generator_slope(&ctrl->rg, ctl_mul(ctrl->rg_slope_default, ctrl->rg_freq_pu));
            ctrl->angle = ctl_step_ramp_generator(&ctrl->rg);
            ctl_set_phasor_via_angle(ctrl->angle, &ctrl->phasor);
        }
        else
        {
            ctrl->angle = ctrl->pll.theta;
            ctrl->phasor = ctrl->pll.phasor;
        }

        // --- 3b. Park Transformation ---
        ctl_ct_park2((ctl_vector2_t*)&ctrl->iab0, &ctrl->phasor, &ctrl->idq);
        ctl_ct_park2((ctl_vector2_t*)&ctrl->vab0, &ctrl->phasor, &ctrl->vdq);

        // --- 3c. Droop Control ---
        if (ctrl->flag_enable_droop)
        {
            ctrl->idq_droop_set.dat[phase_d] = ctl_step_saturation(
                &ctrl->idq_droop_sat[phase_d], ctl_mul(ctrl->kq_droop, ctrl->v_droop_ref - ctrl->vdq.dat[phase_d]));
            ctrl->idq_droop_set.dat[phase_q] = ctl_step_saturation(
                &ctrl->idq_droop_sat[phase_q], ctl_mul(ctrl->kp_droop, float2ctrl(1.0f) - ctrl->pll.freq_pu));
        }
        else
        {
            ctl_vector2_clear(&ctrl->idq_droop_set);
        }

        // --- 3d. Outer Voltage Loop ---
        if (ctrl->flag_enable_voltage_ctrl)
        {
            ctrl->idq_set.dat[phase_d] =
                ctl_step_pid_ser(&ctrl->voltage_ctrl[phase_d], ctrl->vdq_set.dat[phase_d] - ctrl->vdq.dat[phase_d]);
            ctrl->idq_set.dat[phase_q] =
                ctl_step_pid_ser(&ctrl->voltage_ctrl[phase_q], ctrl->vdq_set.dat[phase_q] - ctrl->vdq.dat[phase_q]);
        }

        // --- 3e. Inner Positive-Sequence Current Loop ---
        if (ctrl->flag_enable_current_ctrl)
        {
            ctrl_gt id_ref = ctrl->idq_ff.dat[phase_d] + ctrl->idq_set.dat[phase_d] + ctrl->idq_droop_set.dat[phase_d];
            ctrl_gt iq_ref = ctrl->idq_ff.dat[phase_q] + ctrl->idq_set.dat[phase_q] + ctrl->idq_droop_set.dat[phase_q];

            ctrl->vdq_pos_out.dat[phase_d] =
                ctl_step_pid_ser(&ctrl->current_ctrl[phase_d], id_ref - ctrl->idq.dat[phase_d]);
            ctrl->vdq_pos_out.dat[phase_q] =
                ctl_step_pid_ser(&ctrl->current_ctrl[phase_q], iq_ref - ctrl->idq.dat[phase_q]);

            if (ctrl->flag_enable_decouple_lf)
            {
                ctrl->vdq_pos_out.dat[phase_d] -= ctl_mul(ctrl->omega_L, ctrl->idq.dat[phase_q]);
                // CORRECTED: q-axis voltage is decoupled using d-axis current.
                ctrl->vdq_pos_out.dat[phase_q] += ctl_mul(ctrl->omega_L, ctrl->idq.dat[phase_d]);
            }
        }
        ctl_ct_ipark2(&ctrl->vdq_pos_out, &ctrl->phasor, &ctrl->vab_pos);

        // --- 3f. Negative-Sequence Voltage/Current Loop ---
        if (ctrl->flag_enable_negative_voltage_ctrl)
        {
            ctl_ct_park2_neg((ctl_vector2_t*)&ctrl->vab0, &ctrl->phasor, &ctrl->vdq_neg);
            ctrl->idq_net_set.dat[phase_d] =
                ctl_step_pid_ser(&ctrl->neg_voltage_ctrl[phase_d], -ctrl->vdq_neg.dat[phase_d]);
            ctrl->idq_net_set.dat[phase_q] =
                ctl_step_pid_ser(&ctrl->neg_voltage_ctrl[phase_q], -ctrl->vdq_neg.dat[phase_q]);
        }
        else
        {
            ctl_vector2_clear(&ctrl->idq_net_set);
        }

        if (ctrl->flag_enable_negative_current_ctrl)
        {
            ctl_ct_park2_neg((ctl_vector2_t*)&ctrl->iab0, &ctrl->phasor, &ctrl->idq_neg);
            ctrl->vdq_neg_out.dat[phase_d] = ctl_step_pid_ser(
                &ctrl->neg_current_ctrl[phase_d], ctrl->idq_net_set.dat[phase_d] - ctrl->idq_neg.dat[phase_d]);
            ctrl->vdq_neg_out.dat[phase_q] = ctl_step_pid_ser(
                &ctrl->neg_current_ctrl[phase_q], ctrl->idq_net_set.dat[phase_q] - ctrl->idq_neg.dat[phase_q]);
            ctl_ct_ipark2_neg(&ctrl->vdq_neg_out, &ctrl->phasor, &ctrl->vab_neg);
        }
        else
        {
            ctl_vector2_clear(&ctrl->vab_neg);
        }

        // --- 3g. Harmonic Compensation ---
        if (ctrl->flag_enable_harm_ctrl)
        {
            for (int i = 0; i < 2; ++i)
            {
                ctrl->vab_harm.dat[i] = ctl_step_qr_controller(&ctrl->harm_qr_5[i], -ctrl->iab0.dat[i]);
                ctrl->vab_harm.dat[i] += ctl_step_qr_controller(&ctrl->harm_qr_7[i], -ctrl->iab0.dat[i]);
            }
        }
        else
        {
            ctl_vector2_clear(&ctrl->vab_harm);
        }

        // --- 3h. Zero-Sequence Control ---
        if (ctrl->flag_enable_zero_current_ctrl)
        {
            ctrl->v0_set = ctl_step_pid_ser(&ctrl->zero_pid, -ctrl->iab0.dat[phase_0]);
            ctrl->v0_set += ctl_step_qr_controller(&ctrl->zero_qr_3, -ctrl->iab0.dat[phase_0]);
            ctrl->v0_set += ctl_step_qr_controller(&ctrl->zero_qr_9, -ctrl->iab0.dat[phase_0]);
        }
        else
        {
            ctrl->v0_set = 0;
        }

        // --- 3i. Final Modulation Signal Synthesis ---
        ctrl->vab_out.dat[0] = ctrl->vab_pos.dat[0] + ctrl->vab_neg.dat[0] + ctrl->vab_harm.dat[0];
        ctrl->vab_out.dat[1] = ctrl->vab_pos.dat[1] + ctrl->vab_neg.dat[1] + ctrl->vab_harm.dat[1];
        ctl_ct_iclarke2(&ctrl->vab_out, &ctrl->abc_out);
        ctrl->abc_out.dat[phase_A] += ctrl->v0_set;
        ctrl->abc_out.dat[phase_B] += ctrl->v0_set;
        ctrl->abc_out.dat[phase_C] += ctrl->v0_set;

        // --- 4. SVPWM or SPWM Output ---
        ctrl->pwm_out_pu.dat[phase_A] = ctl_div2(ctl_add(ctrl->abc_out.dat[phase_A], float2ctrl(1)));
        ctrl->pwm_out_pu.dat[phase_B] = ctl_div2(ctl_add(ctrl->abc_out.dat[phase_B], float2ctrl(1)));
        ctrl->pwm_out_pu.dat[phase_C] = ctl_div2(ctl_add(ctrl->abc_out.dat[phase_C], float2ctrl(1)));
    }
    else
    {
        // Disable output if system is not enabled
        ctl_vector3_set(&ctrl->pwm_out_pu, float2ctrl(0.5));
    }
}

//////////////////////////////////////////////////////////////////////////
// Mode Setting Functions
//////////////////////////////////////////////////////////////////////////

/** @brief Sets the controller to open-loop mode. */
GMP_STATIC_INLINE void ctl_set_three_phase_inv_openloop_mode(inv_ctrl_t* inv)
{
    inv->flag_enable_system = 0;
    inv->flag_enable_voltage_ctrl = 0;
    inv->flag_enable_droop = 0;
    inv->flag_enable_current_ctrl = 0;
    inv->flag_enable_decouple_lf = 0;
    inv->flag_enable_harm_ctrl = 0;
    inv->flag_enable_negative_voltage_ctrl = 0;
    inv->flag_enable_negative_current_ctrl = 0;
    inv->flag_enable_pll = 1;
    inv->flag_enable_freerun = 1;
}

/** @brief Sets the open-loop output voltage in the d-q frame. */
GMP_STATIC_INLINE void ctl_set_three_phase_inv_voltage_openloop(inv_ctrl_t* inv, ctrl_gt vd, ctrl_gt vq)
{
    inv->vdq_pos_out.dat[phase_d] = vd;
    inv->vdq_pos_out.dat[phase_q] = vq;
}

/** @brief Sets the controller to current closed-loop mode. */
GMP_STATIC_INLINE void ctl_set_three_phase_inv_current_mode(inv_ctrl_t* inv)
{
    inv->flag_enable_system = 0;
    inv->flag_enable_voltage_ctrl = 0;
    inv->flag_enable_droop = 0;
    inv->flag_enable_current_ctrl = 1;
    inv->flag_enable_decouple_lf = 1;
    inv->flag_enable_harm_ctrl = 0;
    inv->flag_enable_negative_voltage_ctrl = 0;
    inv->flag_enable_negative_current_ctrl = 0;
    inv->flag_enable_pll = 1;
    inv->flag_enable_freerun = 1;
}

/** @brief Sets the target current in the d-q frame. */
GMP_STATIC_INLINE void ctl_set_three_phase_inv_current(inv_ctrl_t* inv, ctrl_gt id, ctrl_gt iq)
{
    inv->idq_set.dat[phase_d] = id;
    inv->idq_set.dat[phase_q] = iq;
}

/** @brief Sets the target current via magnitude and power factor. */
GMP_STATIC_INLINE void ctl_set_three_phase_inv_current_via_pf(inv_ctrl_t* inv, ctrl_gt is, ctrl_gt pf)
{
    inv->idq_set.dat[phase_d] = ctl_mul(is, pf);
    inv->idq_set.dat[phase_q] = ctl_mul(is, ctl_sqrt(ctl_sub(float2ctrl(1), ctl_mul(pf, pf))));
}

/** @brief Sets the controller to voltage closed-loop mode. */
GMP_STATIC_INLINE void ctl_set_three_phase_inv_voltage_mode(inv_ctrl_t* inv)
{
    inv->flag_enable_system = 0;
    inv->flag_enable_voltage_ctrl = 1;
    inv->flag_enable_droop = 0;
    inv->flag_enable_current_ctrl = 1;
    inv->flag_enable_decouple_lf = 1;
    inv->flag_enable_harm_ctrl = 0;
    inv->flag_enable_negative_voltage_ctrl = 0;
    inv->flag_enable_negative_current_ctrl = 0;
    inv->flag_enable_pll = 1;
    inv->flag_enable_freerun = 1;
}

/** @brief Sets the target voltage in the d-q frame (vq is assumed to be 0). */
GMP_STATIC_INLINE void ctl_set_three_phase_inv_voltage(inv_ctrl_t* inv, ctrl_gt vd)
{
    inv->vdq_set.dat[phase_d] = vd;
    inv->vdq_set.dat[phase_q] = 0;
}

/** @brief Sets the frequency of the ramp generator in per-unit. */
GMP_STATIC_INLINE void ctl_set_three_phase_inv_rg_frequency(inv_ctrl_t* inv, ctrl_gt freq_pu)
{
    inv->rg_freq_pu = freq_pu;
}

/** @brief Sets the controller to droop control mode. */
GMP_STATIC_INLINE void ctl_set_three_phase_inv_droop_mode(inv_ctrl_t* inv)
{
    inv->flag_enable_system = 0;
    inv->flag_enable_voltage_ctrl = 0;
    inv->flag_enable_droop = 1;
    inv->flag_enable_current_ctrl = 1;
    inv->flag_enable_decouple_lf = 1;
    inv->flag_enable_harm_ctrl = 0;
    inv->flag_enable_negative_voltage_ctrl = 0;
    inv->flag_enable_negative_current_ctrl = 0;
    inv->flag_enable_pll = 1;
    inv->flag_enable_freerun = 1;
}

/** @brief Sets the reference voltage for droop control. */
GMP_STATIC_INLINE void ctl_set_droop_reference_voltage(inv_ctrl_t* inv, ctrl_gt vref)
{
    inv->v_droop_ref = vref;
}

//////////////////////////////////////////////////////////////////////////
// Utility Functions
//////////////////////////////////////////////////////////////////////////

/** @brief Calculates the output active power (P). */
GMP_STATIC_INLINE ctrl_gt ctl_get_three_phase_inv_Pout(inv_ctrl_t* inv)
{
    return ctl_add(ctl_mul(inv->vdq.dat[phase_d], inv->idq.dat[phase_d]),
                   ctl_mul(inv->vdq.dat[phase_q], inv->idq.dat[phase_q]));
}

/** @brief Calculates the output reactive power (Q). */
GMP_STATIC_INLINE ctrl_gt ctl_get_three_phase_inv_Qout(inv_ctrl_t* inv)
{
    return ctl_sub(ctl_mul(inv->vdq.dat[phase_q], inv->idq.dat[phase_d]),
                   ctl_mul(inv->vdq.dat[phase_d], inv->idq.dat[phase_q]));
}

/** @brief Sets the angle source to the internal ramp generator (freerun). */
GMP_STATIC_INLINE void ctl_set_three_phase_inv_freerun(inv_ctrl_t* inv)
{
    inv->flag_enable_freerun = 1;
}

/** @brief Sets the angle source to the PLL (grid-tied). */
GMP_STATIC_INLINE void ctl_set_three_phase_inv_pll(inv_ctrl_t* inv)
{
    inv->flag_enable_freerun = 0;
}

/** @brief Enables the harmonic compensation controllers. */
GMP_STATIC_INLINE void ctl_enable_three_phase_harm_ctrl(inv_ctrl_t* inv)
{
    inv->flag_enable_harm_ctrl = 1;
}

/** @brief Disables the harmonic compensation controllers. */
GMP_STATIC_INLINE void ctl_disable_three_phase_harm_ctrl(inv_ctrl_t* inv)
{
    inv->flag_enable_harm_ctrl = 0;
}

/** @brief Enables negative-sequence current control only. */
GMP_STATIC_INLINE void ctl_enable_three_phase_negative_current_ctrl(inv_ctrl_t* inv)
{
    inv->flag_enable_negative_current_ctrl = 1;
    inv->flag_enable_negative_voltage_ctrl = 0;
}

/** @brief Enables cascaded negative-sequence voltage and current control. */
GMP_STATIC_INLINE void ctl_enable_three_phase_negative_voltage_ctrl(inv_ctrl_t* inv)
{
    inv->flag_enable_negative_current_ctrl = 1;
    inv->flag_enable_negative_voltage_ctrl = 1;
}

/** @brief Disables all negative-sequence control. */
GMP_STATIC_INLINE void ctl_disable_three_phase_negative_ctrl(inv_ctrl_t* inv)
{
    inv->flag_enable_negative_current_ctrl = 0;
    inv->flag_enable_negative_voltage_ctrl = 0;
}

/** @brief Enables the main system controller. */
GMP_STATIC_INLINE void ctl_enable_three_phase_inverter(inv_ctrl_t* inv)
{
    inv->flag_enable_system = 1;
}

/** @brief Disables the main system controller, setting PWM to 50%. */
GMP_STATIC_INLINE void ctl_disable_three_phase_inverter(inv_ctrl_t* inv)
{
    inv->flag_enable_system = 0;
}

/** @brief Enables the inductor decoupling feed-forward term. */
GMP_STATIC_INLINE void ctl_enable_three_phase_feedforward(inv_ctrl_t* inv)
{
    inv->flag_enable_decouple_lf = 1;
}

/** @brief Disables the inductor decoupling feed-forward term. */
GMP_STATIC_INLINE void ctl_disable_three_phase_feedforward(inv_ctrl_t* inv)
{
    inv->flag_enable_decouple_lf = 0;
}

/** @brief Gets the current error from the PLL. */
GMP_STATIC_INLINE ctrl_gt ctl_get_three_phase_pll_error(inv_ctrl_t* inv)
{
    return inv->pll.e_error;
}

/**
 * @brief Judge if the converter is inverter mode.ctl_is_three_phase_inverter_mode
 */
GMP_STATIC_INLINE ctrl_gt ctl_is_three_phase_inverter_mode(inv_ctrl_t* inv)
{
    (void)inv;
    return 1;
}

/** @brief Checks if the controller is in freerun mode. */
GMP_STATIC_INLINE fast_gt ctl_is_three_phase_inverter_freerun_mode(inv_ctrl_t* inv)
{
    return inv->flag_enable_freerun;
}

/** @brief Clears all runtime states of the inverter controller. */
GMP_STATIC_INLINE void ctl_clear_three_phase_inv(inv_ctrl_t* inv)
{
    ctl_clear_lowpass_filter(&inv->lpf_udc);
    ctl_clear_lowpass_filter(&inv->lpf_idc);

    for (int i = 0; i < 3; ++i)
    {
        ctl_clear_lowpass_filter(&inv->lpf_iabc[i]);
        ctl_clear_lowpass_filter(&inv->lpf_vabc[i]);
    }
    ctl_clear_pid(&inv->voltage_ctrl[phase_d]);
    ctl_clear_pid(&inv->voltage_ctrl[phase_q]);
    ctl_clear_pid(&inv->current_ctrl[phase_d]);
    ctl_clear_pid(&inv->current_ctrl[phase_q]);

    ctl_clear_pid(&inv->neg_voltage_ctrl[phase_d]);
    ctl_clear_pid(&inv->neg_voltage_ctrl[phase_q]);
    ctl_clear_pid(&inv->neg_current_ctrl[phase_d]);
    ctl_clear_pid(&inv->neg_current_ctrl[phase_q]);

    for (int i = 0; i < 2; ++i)
    {
        ctl_clear_qr_controller(&inv->harm_qr_5[i]);
        ctl_clear_qr_controller(&inv->harm_qr_7[i]);
    }

    ctl_clear_pid(&inv->zero_pid);
    ctl_clear_qr_controller(&inv->zero_qr_3);
    ctl_clear_qr_controller(&inv->zero_qr_9);

    ctl_vector2_clear(&inv->idq_ff);
}

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // _FILE_THREE_PHASE_DC_AC_H_

/**
 * @}
 */
