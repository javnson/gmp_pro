// Three phase DC/AC inverter

#ifndef _FILE_THREE_PHASE_DC_AC_H_
#define _FILE_THREE_PHASE_DC_AC_H_

#include <ctl/component/intrinsic/continuous/continuous_pid.h>
#include <ctl/component/intrinsic/continuous/saturation.h>
#include <ctl/component/intrinsic/discrete/discrete_filter.h>
#include <ctl/component/intrinsic/discrete/proportional_resonant.h>
#include <ctl/component/intrinsic/discrete/stimulate.h>

#include <ctl/component/digital_power/three_phase/pll.h>
#include <ctl/math_block/coordinate/coord_trans.h>

#ifndef CURRENT_SAMPLE_PHASE_MODE
// 3: Sample 3 phase current
// 2: Sample 2 phase current
#define CURRENT_SAMPLE_PHASE_MODE (3)
#endif // CURRENT_SAMPLE_PHASE_MODE

#ifndef VOLTAGE_SAMPLE_PHASE_MODE
// 3: Sample 3 phase voltage
// 2: Sample 2 phase voltage
// 1: Sample 2 line voltage
#define VOLTAGE_SAMPLE_PHASE_MODE (3)
#endif // VOLTAGE_SAMPLE_PHASE_MODE

typedef struct _tag_inv_ctrl_type
{
    //
    // input port
    //
    // positive direction: inverter
    //

    // DC Bus voltage
    // positive is u bus
    adc_ift *adc_udc;

    // DC Bus current
    // positive is inverter state
    adc_ift *adc_idc;

    // current measurement
    adc_ift *adc_iabc[3];

    // voltage measurement
    adc_ift *adc_vabc[3];

    //
    // output port
    //

    // channel 0: A phase
    // channel 1: B phase
    // channel 2: C phase
    ctl_vector3_t pwm_out_pu;

    //
    // Feed-forward
    //

    // 2*pi*f*Lf*(i_base/u_base)
    ctrl_gt omega_L;

    //
    // parameters
    //

    // active power droop
    ctrl_gt kp_droop;

    // inactive power droop
    ctrl_gt kq_droop;

    // ramp generator slope
    ctrl_gt rg_slope_default;

    //
    // intermediate variables
    //

    // RW, voltage set
    // writable only in voltage close loop mode
    ctl_vector2_t vdq_set;

    // RW, droop voltage references
    // writable only in droop mode
    ctrl_gt v_droop_ref;

    // RW, rg frequency set
    // valid when using rg as angle source
    ctrl_gt rg_freq_pu;

    // RW, current set
    // writable only in current mode
    ctl_vector2_t idq_set;

    // RW, current controller result, dq
    // writable only when Voltage open loop
    ctl_vector2_t vdq_pos_out;

    // RO, iabc from input filter
    ctl_vector3_t iabc;

    // RO, i alpha-beta measurement
    ctl_vector3_t iab0;

    // measurement current
    ctl_vector2_t idq;

    // RO, vabc from input filter
    ctl_vector3_t vabc;

    // RO, v alpha-beta measurement
    ctl_vector3_t vab0;

    // RO, measurement voltage
    ctl_vector2_t vdq;

    // RO, droop current set
    // generated by droop controller
    ctl_vector2_t idq_droop_set;

    // RO, positive alpha-beta
    ctl_vector2_t vab_pos;

    // RO, modulation total result, alpha-beta
    ctl_vector2_t vab_out;

    // RO, negative dq current
    ctl_vector2_t idq_neg;

    // RO, modulation result, dq, neg
    ctl_vector2_t vdq_neg_out;

    // RO, negative alpha-beta
    ctl_vector2_t vab_neg;

    // RO, harmonic alpha-beta
    ctl_vector2_t vab_harm;

    // RO, current angle
    ctrl_gt angle;

    // RO, current phasor
    ctl_vector2_t phasor;

    //
    // Controller object
    //

    // input filter
    ctl_low_pass_filter_t lpf_udc;
    ctl_low_pass_filter_t lpf_idc;
    ctl_low_pass_filter_t lpf_iabc[3];
    ctl_low_pass_filter_t lpf_vabc[3];

    // PLL object
    three_phase_pll_t pll;

    // ramp generator for free run
    ctl_src_rg_t rg;

    // voltage controller, dq
    ctl_pid_t voltage_ctrl[2];

    // current controller, dq
    ctl_pid_t current_ctrl[2];

    // negative current controller, dq negative
    ctl_pid_t neg_current_ctrl[2];

    // droop output saturation
    ctl_saturation_t idq_droop_sat[2];

    // QR controller for current 3th harmonic, alpha beta
    qr_ctrl_t harm_qr_3[2];

    // QR controller for current 5th harmonic, alpha beta
    qr_ctrl_t harm_qr_5[2];

    // QR controller for current 7th harmonic, alpha beta
    qr_ctrl_t harm_qr_7[2];

    // QR controller for current 9th harmonic, alpha beta
    qr_ctrl_t harm_qr_9[2];

    //
    // flag stack
    //

    // system enable
    fast_gt flag_enable_system;

    // voltage controller
    fast_gt flag_enable_voltage_ctrl;

    // voltage droop control
    // enable droop will add a extra feed forward item for idq set
    fast_gt flag_enable_droop;

    // current controller
    fast_gt flag_enable_current_ctrl;

    // current feed forward
    fast_gt flag_enable_current_ff;

    // harmonic controller
    fast_gt flag_enable_harm_ctrl;

    // negative current controller
    fast_gt flag_enable_negative_current_ctrl;

    // PLL
    fast_gt flag_enable_pll;

    // Select angle source
    // 1: angle information is from rg
    // 0: angle information is from pll
    fast_gt flag_enable_freerun;

} inv_ctrl_t;

GMP_STATIC_INLINE
void ctl_step_inv_ctrl(inv_ctrl_t *ctrl)
{
    //
    // input filter
    //
    ctl_step_lowpass_filter(&ctrl->lpf_udc, ctrl->adc_udc->value);
    ctl_step_lowpass_filter(&ctrl->lpf_idc, ctrl->adc_idc->value);

    //
    // step current filter
    // current Clark
    //
#if CURRENT_SAMPLE_PHASE_MODE == 3

    for (size_gt i = 0; i < 3; ++i)
        ctrl->iabc.dat[i] = ctl_step_lowpass_filter(&ctrl->lpf_iabc[i], ctrl->adc_iabc[i]);

    ctl_ct_clark(&ctrl->iabc, &ctrl->iab0);

#elif CURRENT_SAMPLE_PHASE_MODE == 2

    for (size_gt i = 0; i < 2; ++i)
        ctrl->iabc.dat[i] = ctl_step_lowpass_filter(&ctrl->lpf_iabc[i], ctrl->adc_iabc[i]);
    ctrl->iabc.dat[phase_C] = 0;

    ctl_ct_clark_2ph((ctl_vector2_t *)&ctrl->iabc, (ctl_vector2_t *)&ctrl->iab0);
    ctrl->iab0.dat[phase_0] = 0;

#endif // CURRENT_SAMPLE_PHASE_MODE

    //
    // voltage Clark
    //
#if VOLTAGE_SAMPLE_PHASE_MODE == 3

    for (size_gt i = 0; i < 3; ++i)
        ctrl->vabc.dat[i] = ctl_step_lowpass_filter(&ctrl->lpf_vabc[i], ctrl->adc_vabc[i]);

    ctl_ct_clark(&ctrl->vabc, &ctrl->vab0);

#elif VOLTAGE_SAMPLE_PHASE_MODE == 2

    for (size_gt i = 0; i < 2; ++i)
        ctrl->vabc.dat[i] = ctl_step_lowpass_filter(&ctrl->lpf_vabc[i], ctrl->adc_vabc[i]);
    ctrl->vabc.dat[phase_C] = 0;

    ctl_ct_clark_2ph((ctl_vector2_t *)&ctrl->vabc, (ctl_vector2_t *)&ctrl->vab0);
    ctrl->vab0.dat[phase_0] = 0;

#elif VOLTAGE_SAMPLE_PHASE_MODE == 1

    for (size_gt i = 0; i < 2; ++i)
        ctrl->vabc.dat[i] = ctl_step_lowpass_filter(&ctrl->lpf_vabc[i], ctrl->adc_vabc[i]);
    ctrl->vabc.dat[phase_C] = 0;

    ctl_ct_clark_from_line((ctl_vector2_t *)&ctrl->vabc, (ctl_vector2_t *)&ctrl->vab0);
    ctrl->vab0.dat[phase_0] = 0;

#endif // VOLTAGE_SAMPLE_PHASE_MODE

    //
    // three phase PLL
    //
    if (ctrl->flag_enable_pll)
    {
        ctrl->angle = ctl_step_pll_3ph(&ctrl->pll, ctrl->vab0.dat[phase_alpha], ctrl->vab0.dat[phase_beta]);
    }

    //
    // controller body
    //
    if (ctrl->flag_enable_system)
    {
        //
        // ramp generator
        //
        ctl_set_ramp_freq(ctl_mul(ctrl->rg_slope_default, ctrl->rg_freq_pu));
        ctrl->angle = ctl_step_ramp_gen(&ctrl->rg);

        //
        // inverter phasor
        //
        if (ctrl->flag_enable_freerun)
        {
            ctl_set_phasor_via_angle(ctrl->angle, ctrl->phasor);
        }
        else
        {
            ctrl->phasor.dat[0] = ctrl->pll.phasor.dat[0];
            ctrl->phasor.dat[1] = ctrl->pll.phasor.dat[1];
        }

        //
        // park
        //
        ctl_ct_park2(&ctrl->iab0, &phasor, &ctrl->idq);
        ctl_ct_park2(&ctrl->vab0, &phasor, &ctrl->vdq);

        //
        // droop control
        //
        if (ctrl->flag_enable_droop)
        {
            // voltage droop control
            ctrl->idq_droop_set.dat[phase_d] = ctl_step_saturation(
                &ctrl->idq_droop_sat[phase_d], ctl_mul(ctrl->kq_droop, ctrl->v_droop_ref - ctrl->vdq.dat[phase_d]));

            // frequency droop control
            ctrl->idq_droop_set.dat[phase_q] = ctl_step_saturation(
                &ctrl->idq_droop_sat[phase_q], ctl_mul(ctrl->kp_droop, float2ctrl(1.0f) - ctrl->pll.freq_pu));
        }
        else
        {
            ctrl->idq_droop_set.dat[phase_d] = 0;
            ctrl->idq_droop_set.dat[phase_q] = 0;
        }

        //
        // voltage outer loop
        //
        if (ctrl->flag_enable_voltage_ctrl)
        {
            ctrl->idq_set[phase_d] =
                ctl_step_pid_ser(&ctrl->voltage_ctrl[phase_d], ctrl->vdq_set[phase_d] - ctrl->vdq[phase_d]);

            ctrl->idq_set[phase_q] =
                ctl_step_pid_ser(&ctrl->voltage_ctrl[phase_q], ctrl->vdq_set[phase_q] - ctrl->vdq[phase_q]);
        }

        //
        // current positive loop
        //
        if (ctrl->flag_enable_current_ctrl)
        {
            ctrl->vdq_pos_out[phase_d] =
                ctl_step_pid_ser(&ctrl->current_ctrl[phase_d], ctrl->idq_set[phase_d] - ctrl->idq[phase_d]);
            ctrl->vdq_pos_out[phase_q] =
                ctl_step_pid_ser(&ctrl->current_ctrl[phase_q], ctrl->idq_set[phase_q] - ctrl->idq[phase_q]);

            if (ctrl->flag_enable_current_ff)
            {
                ctrl->vdq_pos_out[phase_d] -= ctl_mul(ctrl->omega_L, ctrl->idq.dat[phase_q]);
                ctrl->vdq_pos_out[phase_q] += ctl_mul(ctrl->omega_L, ctrl->idq.dat[phase_q]);
            }
        }

        //
        // modulation
        //
        ctl_ct_ipark2(&ctrl->vdq_pos_out, &phasor, &ctrl->vab_pos);

        //
        // current negative loop
        //
        if (ctrl->flag_enable_negative_current_ctrl)
        {
            ctl_ct_park2_neg(&ctrl->iab0, ctrl->phasor, &ctrl->idq_neg);

            // negative controller
            ctrl->vab_neg[phase_d] = ctl_step_pid_ser(&ctrl->neg_current_ctrl[phase_d], -ctrl->idq_neg[phase_d]);
            ctrl->vab_neg[phase_q] = ctl_step_pid_ser(&ctrl->neg_current_ctrl[phase_q], -ctrl->idq_neg[phase_q]);
        }
        else
        {
            ctl_vector2_clear(&ctrl->vab_neg);
        }

        //
        // harm control
        //
        if (ctrl->flag_enable_harm_ctrl)
        {
            // for alpha & beta
            for (int i = 0; i < 2; ++i)
            {
                ctrl->vab_harm[i] = ctl_step_qr_controller(&ctrl->harm_qr_3[i], -ctrl->iab0[i]);
                ctrl->vab_harm[i] += ctl_step_qr_controller(&ctrl->harm_qr_5[i], -ctrl->iab0[i]);
                ctrl->vab_harm[i] += ctl_step_qr_controller(&ctrl->harm_qr_7[i], -ctrl->iab0[i]);
                ctrl->vab_harm[i] += ctl_step_qr_controller(&ctrl->harm_qr_9[i], -ctrl->iab0[i]);
            }
        }
        else
        {
            ctl_vector2_clear(&ctrl->vab_harm);
        }

        //
        // mix them up
        //
        ctrl->vab_out.dat[0] = ctrl->vab_pos.dat[0] + ctrl->vab_neg.dat[0] + ctrl->vab_harm.dat[0];
        ctrl->vab_out.dat[1] = ctrl->vab_pos.dat[1] + ctrl->vab_neg.dat[1] + ctrl->vab_harm.dat[1];

        //
        // modulation
        //
        ctl_ct_iclark2(&ctrl->vab_out, ctrl->pwm_out_pu);
    }
    else
    {
        ctrl->pwm_out_pu.dat[phase_A] = float2ctrl(0.5);
        ctrl->pwm_out_pu.dat[phase_B] = float2ctrl(0.5);
        ctrl->pwm_out_pu.dat[phase_C] = float2ctrl(0.5);
    }
}

//////////////////////////////////////////////////////////////////////////
// Voltage Open loop mode

void ctl_set_three_phase_inv_openloop_mode(inv_ctrl_t *inv)
{
    // enable system
    inv->flag_enable_system = 0;

    // voltage controller
    inv->flag_enable_voltage_ctrl = 0;

    // voltage droop control
    // enable droop will add a extra feed forward item for idq set
    inv->flag_enable_droop = 0;

    // current controller
    inv->flag_enable_current_ctrl = 0;

    // current feed forward
    inv->flag_enable_current_ff = 0;

    // harmonic controller
    inv->flag_enable_harm_ctrl = 0;

    // negative current controller
    inv->flag_enable_negative_current_ctrl = 0;

    // PLL
    inv->flag_enable_pll = 1;

    // Select angle source
    // 1: angle information is from rg
    // 0: angle information is from pll
    inv->flag_enable_freerun = 1;
}

GMP_STATIC_INLINE
void ctl_set_three_phase_inv_voltage_openloop(inv_ctrl_t *inv, ctrl_gt vd)
{
    inv->vdq_pos_out.dat[phase_d] = vd;
    inv->vdq_pos_out.dat[phase_q] = 0;
}

//////////////////////////////////////////////////////////////////////////
// Current mode

void ctl_set_three_phase_inv_current_mode(inv_ctrl_t *inv)
{
    // enable system
    inv->flag_enable_system = 0;

    // voltage controller
    inv->flag_enable_voltage_ctrl = 0;

    // voltage droop control
    // enable droop will add a extra feed forward item for idq set
    inv->flag_enable_droop = 0;

    // current controller
    inv->flag_enable_current_ctrl = 1;

    // current feed forward
    inv->flag_enable_current_ff = 1;

    // harmonic controller
    inv->flag_enable_harm_ctrl = 0;

    // negative current controller
    inv->flag_enable_negative_current_ctrl = 0;

    // PLL
    inv->flag_enable_pll = 1;

    // Select angle source
    // 1: angle information is from rg
    // 0: angle information is from pll
    inv->flag_enable_freerun = 1;
}

GMP_STATIC_INLINE
void ctl_set_three_phase_inv_current(inv_ctrl_t *inv, ctrl_gt id, ctrl_gt iq)
{
    inv->idq_set.dat[phase_d] = id;
    inv->idq_set.dat[phase_q] = iq;
}

GMP_STATIC_INLINE
void ctl_set_three_phase_inv_current_via_pf(inv_ctrl_t *inv, ctrl_gt is, ctrl_gt pf)
{
    inv->idq_set.dat[phase_d] = id * pf;
    inv->idq_set.dat[phase_q] = iq * ctl_sqrt(float2ctrl(1) - pf * pf);
}

GMP_STATIC_INLINE
void ctl_enable_three_phase_inv_harm_control(inv_ctrl_t *inv)
{
    inv->flag_enable_harm_ctrl = 1;
}

GMP_STATIC_INLINE
void ctl_disable_three_phase_inv_harm_control(inv_ctrl_t *inv)
{
    inv->flag_enable_harm_ctrl = 0;
}

//////////////////////////////////////////////////////////////////////////
// Voltage mode
// WARNING Voltage loop and droop mode is compatible

void ctl_set_three_phase_inv_current_mode(inv_ctrl_t *inv)
{
    // enable system
    inv->flag_enable_system = 0;

    // voltage controller
    inv->flag_enable_voltage_ctrl = 1;

    // voltage droop control
    // enable droop will add a extra feed forward item for idq set
    inv->flag_enable_droop = 0;

    // current controller
    inv->flag_enable_current_ctrl = 1;

    // current feed forward
    inv->flag_enable_current_ff = 1;

    // harmonic controller
    inv->flag_enable_harm_ctrl = 0;

    // negative current controller
    inv->flag_enable_negative_current_ctrl = 0;

    // PLL
    inv->flag_enable_pll = 1;

    // Select angle source
    // 1: angle information is from rg
    // 0: angle information is from pll
    inv->flag_enable_freerun = 1;
}

GMP_STATIC_INLINE
void ctl_set_three_phase_inv_voltage(inv_ctrl_t *inv, ctrl_gt vd)
{
    inv->vdq_set.dat[phase_d] = vd;
    inv->vdq_set.dat[phase_q] = 0;
}

GMP_STATIC_INLINE
void ctl_set_three_phase_inv_rg_frequency(inv_ctrl_t *inv, ctrl_gt freq_pu)
{
    inv->rg_freq_pu = freq_pu;
}

//////////////////////////////////////////////////////////////////////////
// Droop mode

void ctl_set_three_phase_inv_current_mode(inv_ctrl_t *inv)
{
    // enable system
    inv->flag_enable_system = 0;

    // voltage controller
    inv->flag_enable_voltage_ctrl = 0;

    // voltage droop control
    // enable droop will add a extra feed forward item for idq set
    inv->flag_enable_droop = 1;

    // current controller
    inv->flag_enable_current_ctrl = 1;

    // current feed forward
    inv->flag_enable_current_ff = 1;

    // harmonic controller
    inv->flag_enable_harm_ctrl = 0;

    // negative current controller
    inv->flag_enable_negative_current_ctrl = 0;

    // PLL
    inv->flag_enable_pll = 1;

    // Select angle source
    // 1: angle information is from rg
    // 0: angle information is from pll
    inv->flag_enable_freerun = 1;
}

GMP_STATIC_INLINE
void ctl_set_droop_reference_voltage(inv_ctrl_t *inv, ctrl_gt vref)
{
    ctrl->v_droop_ref = vref;
}

//////////////////////////////////////////////////////////////////////////
// Other utilities function

GMP_STATIC_INLINE ctrl_gt ctl_get_three_phase_inv_Pout(inv_ctrl_t *inv)
{
    return ctl_mul(inv->vdq.dat[phase_d], inv->idq.dat[phase_d]) +
           ctl_mul(inv->vdq.dat[phase_q], inv->idq.dat[phase_q]);
}

GMP_STATIC_INLINE
ctrl_gt ctl_get_three_phase_inv_Qout(inv_ctrl_t *inv)
{
    return ctl_mul(inv->vdq.dat[phase_q], inv->idq.dat[phase_d]) -
           ctl_mul(inv->vdq.dat[phase_d], inv->idq.dat[phase_q]);
}

GMP_STATIC_INLINE void ctl_enable_three_phase_inverter(inv_ctrl_t *inv)
{
    inv->flag_enable_system = 1;
}

GMP_STATIC_INLINE
void ctl_disable_three_phase_inverter(inv_ctrl_t *inv)
{
    inv->flag_enable_system = 0;
}

GMP_STATIC_INLINE
void ctl_clear_three_phase_inv(inv_ctrl_t *inv)
{
    ctl_clear_lowpass_filter(&inv->lpf_udc);
    ctl_clear_lowpass_filter(&inv->lpf_idc);

    for (int i = 0; i < 3; ++i)
    {
        ctl_clear_lowpass_filter(&inv->lpf_iabc[i]);
        ctl_clear_lowpass_filter(&inv->lpf_vabc[i]);
    }
    ctl_clear_pid(&inv->voltage_ctrl[phase_d]);
    ctl_clear_pid(&inv->voltage_ctrl[phase_q]);
    ctl_clear_pid(&inv->current_ctrl[phase_d]);
    ctl_clear_pid(&inv->current_ctrl[phase_q]);

    ctl_clear_pid(&inv->neg_current_ctrl[phase_d]);
    ctl_clear_pid(&inv->neg_current_ctrl[phase_q]);

    for (int i = 0; i < 2; ++i)
    {
        ctl_clear_qr_controller(&inv->harm_qr_3[i]);
        ctl_clear_qr_controller(&inv->harm_qr_5[i]);
        ctl_clear_qr_controller(&inv->harm_qr_7[i]);
        ctl_clear_qr_controller(&inv->harm_qr_9[i]);
    }
}

//////////////////////////////////////////////////////////////////////////
// Init function

typedef struct _tag_three_phase_inv_init_type
{
    //
    // General parameters
    //

    // voltage base
    parameter_gt v_base;

    // current base value
    parameter_gt i_base;

    // grid base frequency
    parameter_gt freq_base;

    // grid connect filter inductor, H
    parameter_gt Lf;

    // controller frequency
    parameter_gt fs;

    // adc input filter cut frequency
    parameter_gt adc_fc;

    //
    // Basic parameters
    //

    // PI parameters for id controller
    parameter_gt kp_id_ctrl;
    parameter_gt Ti_id_ctrl;

    // PI parameters for iq controller
    parameter_gt kp_iq_ctrl;
    parameter_gt Ti_iq_ctrl;

    // PI parameters for vd controller
    parameter_gt kp_vd_ctrl;
    parameter_gt Ti_vd_ctrl;

    // PI parameters for vq controller
    parameter_gt kp_vq_ctrl;
    parameter_gt Ti_vq_ctrl;

    // PI parameters for PLL controller
    parameter_gt kp_pll_ctrl;
    parameter_gt Ti_pll_ctrl;

    //
    // negative current controller
    //

    // negative id controller
    parameter_gt kp_idn_ctrl;
    parameter_gt Ti_idn_ctrl;

    // negative iq controller
    parameter_gt kp_iqn_ctrl;
    parameter_gt Ti_iqn_ctrl;

    //
    // Harmonic controller
    //

    parameter_gt harm_ctrl_kr_3;
    parameter_gt harm_ctrl_cut_freq_3;
    parameter_gt harm_ctrl_kr_5;
    parameter_gt harm_ctrl_cut_freq_5;
    parameter_gt harm_ctrl_kr_7;
    parameter_gt harm_ctrl_cut_freq_7;
    parameter_gt harm_ctrl_kr_9;
    parameter_gt harm_ctrl_cut_freq_9;

    //
    // droop parameters
    //

    // active power droop
    parameter_gt kp_droop;

    // inactive power droop
    parameter_gt kq_droop;

    // droop control current range
    parameter_gt id_lim_droop;
    parameter_gt iq_lim_droop;

} three_phase_inv_init_t;

void ctl_upgrade_three_phase_inv(inv_ctrl_t *inv, three_phase_inv_init_t *init);

void ctl_init_three_phase_inv(inv_ctrl_t *inv, three_phase_inv_init_t *init);

void ctl_attach_three_phase_inv(
    // handle of inverter
    inv_ctrl_t *inv,
    // DC bus interface
    adc_ift *adc_udc, adc_ift *adc_idc,
    // iabc
    adc_ift *adc_ia, adc_ift *adc_ib, adc_ift *adc_ic,
    // ubac
    adc_ift *adc_ua, adc_ift *adc_ub, adc_ift adc_uc);

#endif // _FILE_THREE_PHASE_DC_AC_H_
