# CTL (Control Template Library) 电机控制库 - 说明文档

## 简介

CTL (Control Template Library) 电机控制库是一个为嵌入式系统设计的高性能、模块化电机控制算法库。它旨在提供一套标准化的、可重用的组件，用于快速开发和部署针对永磁同步电机（PMSM）、异步电机（ACM）等各类电机的控制系统。

该库的核心思想是模块化和接口标准化，允许开发者像搭积木一样组合不同的功能模块，以适应从简单的开环控制到复杂的高性能闭环磁场定向控制（FOC）等各种应用场景。

## 模块概览

CTL库被划分为多个功能层级，每个层级包含一组特定的模块。主要的模块类别包括：

* **核心模块 (Basic Components)**: 提供电机控制最基础的构建块。
* **顾问模块 (Consultant Modules)**: 用于管理、计算和转换电机及驱动器参数。
* **电流控制器 (Current Controller)**: 实现电流闭环控制的核心。
* **轨迹规划与运动控制 (Trajectory Planning & Motion Control)**: 负责生成平滑的运动曲线并实现位置/速度闭环控制。
* **观测器 (Observer)**: 用于估算电机状态，如转速、位置和磁链。
* **电机控制器 (Motor Controller)**: 针对特定电机类型的高度集成的控制方案。
* **预设模块 (Presets)**: 提供针对特定电机和逆变器硬件的参数预设。

---

## 核心模块 (Basic Components)

核心模块是构成所有高级控制器的基础。它们提供了独立的功能，如传感器数据处理、坐标变换、PWM生成等。

* **通用电机接口 (`motor_universal_interface.h`)**: 定义了标准化的传感器和执行器接口（如`rotation_ift`, `velocity_ift`），并通过一个聚合结构体`mtr_ift`将它们统一起来，实现上层算法与底层硬件的解耦。
* **编码器处理 (`encoder.h`)**: 提供对多种编码器（单圈/多圈绝对值编码器、自动计圈编码器）数据的处理功能，并内置一个根据位置微分计算速度的工具。
* **编码器校准 (`encoder_calibrate.h`)**: 实现了一个自动化的状态机，通过注入d轴电流使转子定位，用于校准绝对位置编码器的电气零点偏移。
* **SVPWM 生成 (`svpwm.h`)**: 实现了空间矢量脉宽调制算法，将α-β静止坐标系下的电压指令矢量转换为三相PWM占空比。
* **电压解耦 (`decouple.h`)**: 提供FOC中d-q轴电流环所需的交叉耦合项前馈电压计算，支持PMSM和ACM。
* **V/F 曲线生成 (`vf_generator.h`)**: 用于实现开环的V/F（电压/频率）控制，包含恒定频率、斜坡频率和完整的V/F曲线发生器。
* **电压重构 (`voltage_calculator.h`)**: 根据直流母线电压和SVPWM占空比，反向计算出施加到电机上的三相交流电压和α-β坐标系电压。
* **软件在环 (SIL) 接口 (`std_sil_motor_interface.h`)**: 定义了与Simulink等仿真环境进行数据交换的标准接口结构体，通过`#pragma pack(1)`确保跨平台数据兼容性。

---

## 顾问模块 (Consultant Modules)

“顾问”模块是CTL库的一大特色。它们将复杂的参数计算、单位换算和控制器整定过程封装起来，形成一系列易于使用的“参数专家”，极大地简化了系统配置流程。

* **单位制与参数变换 (`motor_unit_calculator.h`)**: 提供了一系列预定义的物理常量和单位换算宏，是所有参数计算的基础。
* **标幺制顾问 (`motor_per_unit_consultant.h`)**: 根据系统的基本额定值（功率、电压、频率），自动计算出一整套一致的标幺化基准值。
* **驱动器顾问 (`motor_driver_consultant.h`)**: 通过编译时宏和运行时结构体，集中管理与电机驱动硬件和控制器软件配置相关的参数（如电源额定值、控制频率、ADC参数等）。
* **PMSM/ACM 顾问 (`pmsm_consultant.h`, `acm_consultant.h`)**: 针对特定电机类型，管理其铭牌和设计参数，并提供衍生参数计算（如转矩常数）和PI控制器自动调谐功能。

---

## 电流控制器 (Current Controller)

电流控制是高性能电机驱动的核心环节。本库提供了多种电流控制方案，从经典的PI控制器到先进的控制策略，以及完整的电流参考生成逻辑。

* **FOC核心电流环 (`motor_current_ctrl.h`)**: 标准的FOC电流调节器，包含坐标变换和d-q轴PI控制器，是大多数控制策略的基础。
* **电流参考生成策略**:
    * **通用电流分配器 (`current_distributor.h`)**: 通过查找表（LUT）将总电流指令分解为Id和Iq，可实现自定义的电流分配策略。
    * **最大转矩电流比 (MTPA) (`mtpa.h`, `mtpa_pu.h`)**: 专为凸极电机设计，通过解析公式计算最优的Id和Iq，以实现最高效率。
    * **弱磁控制 (MTPV) (`mtpv.h`, `mtpv_pu.h`)**: 用于超基速运行，通过注入负d轴电流来降低反电势，扩展电机的高速运行范围。
* **高级/替代电流控制器**:
    * **线性自抗扰控制器 (LADRC) (`ladrc_current_controller.h`)**: 基于扩张状态观测器（LESO），能主动补偿系统扰动，鲁棒性强，参数整定简单。
    * **无差拍预测控制器 (DPCC) (`pmsm_dpcc.h`)**: 基于模型的预测控制器，旨在实现极快的电流动态响应，理论上可在一个周期内消除误差。
    * **直接转矩控制 (DTC) (`dtc.h`)**: 一种与FOC不同的高性能控制策略，通过滞环直接控制磁链和转矩，动态响应极快。

---

## 轨迹规划与运动控制 (Trajectory Planning & Motion Control)

本章模块负责生成平滑的运动曲线并实现高层的运动闭环控制。

* **运动轨迹生成器**:
    * **梯形速度轨迹 (`trapezoidal_trajectory.h`)**: 经典的位置规划器，实现匀加速-匀速-匀减速运动，算法简单。
    * **S型速度轨迹 (`s_curve_trajectory.h`)**: 通过控制加加速度（Jerk）来平滑速度曲线，运动平稳，冲击小。
    * **正弦（摆线）轨迹 (`sinusoidal_trajectory.h`)**: 基于摆线函数生成轨迹，提供最佳的平滑度，加速度和冲击在起止点均为零。
* **位置/速度控制器**:
    * **基础P控制器位置环 (`basic_pos_loop_p.h`)**: 标准的比例（P）位置控制器，用于伺服应用。
    * **触感旋钮位置环 (`knob_pos_loop.h`)**: 模拟带有“咔哒”感的物理旋钮，用于人机交互。
    * **线性自抗扰速度控制器 (LADRC) (`ladrc_spd_ctrl.h`)**: 用于速度环的鲁棒控制器，对负载变化不敏感。

---

## 观测器 (Observer)

观测器是高级电机控制算法的“眼睛”，尤其是在无传感器（Sensorless）控制中，它负责根据外部电气量推算电机的内部状态。

* **PMSM 观测器**:
    * **有感磁链观测器 (`pmsm.fo.h`)**: 需要位置传感器，用于精确计算定子磁链和转矩。
    * **滑模观测器 (SMO) (`pmsm.smo.h`)**: 经典的无传感器位置估算方法，通过跟踪反电动势实现，适用于中高转速。
    * **高频注入观测器 (HFI) (`pmsm.hfi.h`)**: 专用于零速和低速的无传感器位置估算技术，利用电机凸极效应。
* **异步电机 (ACM) 观测器**:
    * **有感磁链观测器 (`acm.fo.h`)**: 基于电压模型，估算转子磁链和转矩。
    * **转子磁场角度估算器 (`acm.pos_calc.h`)**: 实现异步电机间接磁场定向控制（IFOC）的核心，通过计算转差率来确定磁场角度。

---

## 电机控制器 (Motor Controller)

电机控制器模块是本库的顶层应用封装，它们将底层组件集成为针对特定电机类型的、可以直接使用的完整解决方案。

* **永磁同步电机 (PMSM) 控制器**:
    * **标准有感FOC控制器 (`pmsm_ctrl.h`)**: 基础的、需要编码器的三闭环FOC控制器。
    * **MTPA FOC 控制器 (`pmsm_ctrl_mtpa.h`)**: 在标准FOC基础上集成了MTPA策略，以提升效率。
    * **SMO无传感器控制器 (`pmsm_ctrl_smo.h`)**: 集成了SMO和开环启动逻辑，适用于中高速无传感器应用。
    * **HFI无传感器控制器 (`pmsm_ctrl_hfi.h`)**: 集成了HFI观测器，适用于零低速无传感器应用。
* **异步电机 (ACM) 控制器**:
    * **标准有感FOC控制器 (`acm_sensored_ctrl.h`)**: 实现了基于转子磁场定向的IFOC控制，需要速度传感器。

---

## 预设模块 (Presets)

预设模块提供了一系列针对特定硬件平台或算法的预定义参数，旨在实现“即插即用”的快速开发体验。

* **硬件参数预设**: 为特定的逆变器硬件板卡定义了关键的物理参数，主要是ADC采样电路的标定值。
    * `GMP_LV_3PH_GAN_INV.h`, `GMP_3PH_213L6SINV_DUAL.h`, `SE_PWR_BD.h`, `TI_3PH_GAN_INV.h`
* **算法参数预设**:
    * `CURRENT_DISTRIBUTOR_LUT.h`: 为**通用电流分配器**提供了一个预设的查找表，用于实现定制化的电流分配策略。
* **电机参数预设**: 为特定的电机型号提供了完整的参数集。
    * `ACM_4P24V.h`, `GBM2804H_100T.h`, `HBL48ZL400330K.h`, `PMSRM_4P_15KW520V.h`, `TYI_5008_KV335.h`, `TYI_5010_360KV.h`

---

## 如何使用CTL库 (How to Use the CTL Library)

使用本库来构建一个电机控制应用的典型流程如下：

1.  **项目设置与参数配置**:
    * 在您的工程中，首先包含您选择的**电机参数预设**头文件（例如 `TYI_5008_KV335.h`）和**硬件参数预设**头文件（例如 `GMP_LV_3PH_GAN_INV.h`）。这些文件通过宏定义提供了大部分所需的基础参数。
    * 使用这些预设的宏，初始化**顾问模块**（如 `pmsm_consultant_t`, `motor_driver_consultant_t`），顾问模块将帮助您自动计算衍生参数和控制器增益。

2.  **选择并初始化控制器**:
    * 根据您的应用需求，从**电机控制器**模块中选择一个顶层控制器（例如，需要编码器则选择 `pmsm_ctrl.h`，需要中高速无感则选择 `pmsm_ctrl_smo.h`）。
    * 定义一个该控制器的实例（如 `pmsm_bare_controller_t my_motor;`）。
    * 创建一个对应的初始化结构体（如 `pmsm_bare_controller_init_t init_params;`），并使用**顾问模块**中计算好的参数来填充它。
    * 调用该控制器的初始化函数（如 `ctl_init_pmsm_bare_controller(&my_motor, &init_params);`）。

3.  **挂载硬件接口**:
    * 在您的平台相关代码中，初始化ADC、PWM和编码器等硬件驱动，并让它们的数据符合**核心模块**中定义的接口标准（如 `tri_adc_ift`, `tri_pwm_ift`, `rotation_ift`）。
    * 使用控制器提供的 `ctl_attach_*` 函数，将这些硬件接口实例挂载到电机控制器上。这是连接软件算法和物理硬件的关键一步。

4.  **实现控制中断服务程序 (ISR)**:
    * 在定时器中断中，按照“**采样-计算-输出**”的顺序调用CTL库的函数：
        ```c
        void control_isr() {
            // 1. 采样：更新来自ADC和编码器的输入
            update_adc_inputs(&my_motor.mtr_interface);
            update_encoder_inputs(&my_motor.mtr_interface);

            // 2. 计算：执行控制器核心算法
            ctl_step_pmsm_ctrl(&my_motor);

            // 3. 输出：将计算结果写入PWM寄存器
            update_pwm_outputs(my_motor.pwm_out);
        }
        ```

5.  **控制模式与启停**:
    * 在主循环或状态机中，通过调用控制器提供的API来控制电机。
    * 在启动前，务必调用 `ctl_clear_*_ctrl()` 函数来清除历史状态。
    * 调用 `ctl_enable_*_ctrl()` 来使能控制器。
    * 根据需要，调用模式切换函数（如 `ctl_pmsm_ctrl_velocity_mode()`）并设置目标值（如 `ctl_set_pmsm_ctrl_speed()`）。

---

## 如何拓展CTL库 (How to Extend the CTL Library)

CTL库在设计上鼓励拓展。如果您希望添加新的算法模块，请遵循以下原则和步骤：

* **核心设计理念**: **模块化**和**接口标准化**。一个新的模块应该是一个功能内聚的单元，并通过标准接口与其他模块交互。

* **遵循标准接口**:
    * 如果您要开发一个**新的观测器**，它应该提供一个标准的 `rotation_ift` 或 `velocity_ift` 作为输出，以便上层的控制器可以无缝地将其挂载为位置/速度反馈源。
    * 如果您要开发一个**新的硬件抽象**（例如一个新的ADC驱动），它应该将其数据打包成 `tri_adc_ift` 等标准接口，供上层控制器使用。

* **添加新模块的步骤 (以新观测器为例)**:
    1.  **创建文件**: 新建一个头文件，例如 `pmsm_my_observer.h`。
    2.  **定义数据结构**: 在文件中定义该观测器所需的数据结构，例如 `pmsm_my_observer_t`。
    3.  **提供标准输出**: 在您的数据结构中，**必须**包含一个标准输出接口，例如 `rotation_ift encif;`。
    4.  **编写API**: 提供标准的 `init`, `setup`, `step` 和 `clear` 函数。`step` 函数负责执行核心算法，并将其最终估算出的位置和速度更新到 `encif` 成员中。
    5.  **集成与测试**: 在一个顶层的**电机控制器**中，增加一个该观测器的实例，并通过 `ctl_attach_mtr_position()` 函数将其挂载到FOC算法上，进行测试。

* **代码风格与约定**:
    * 所有公共API函数应以 `ctl_` 开头。
    * 尽可能使用 `GMP_STATIC_INLINE` 来定义高频调用的函数，以提升性能。
    * 为所有数据结构、函数和重要参数编写清晰的Doxygen风格注释，以便自动生成文档。
