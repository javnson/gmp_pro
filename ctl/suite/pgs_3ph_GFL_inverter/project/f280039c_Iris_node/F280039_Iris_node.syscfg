/**
 * These arguments were used when this file was generated. They will be automatically applied on subsequent loads
 * via the GUI or CLI. Run CLI with '--help' for additional information on how to override these arguments.
 * @cliArgs --device "F28003x" --part "F28003x_100PZ" --package "100PZ" --context "system" --product "gmp_pro@1.00.00.05" --product "C2000WARE@5.03.00.00"
 * @v2CliArgs --device "TMS320F280039C" --package "100PZ" --context "system" --product "gmp_pro@1.00.00.05" --product "C2000WARE@5.03.00.00"
 * @versions {"tool":"1.21.0+3721"}
 */

/**
 * Import the modules used in this configuration.
 */
const adc            = scripting.addModule("/driverlib/adc.js", {}, false);
const adc1           = adc.addInstance();
const adc2           = adc.addInstance();
const adc3           = adc.addInstance();
const analog         = scripting.addModule("/driverlib/analog.js", {}, false);
const analog1        = analog.addInstance();
const fsi            = scripting.addModule("/driverlib/board_components/fsi", {}, false);
const fsi1           = fsi.addInstance();
const can            = scripting.addModule("/driverlib/can.js", {}, false);
const can1           = can.addInstance();
const cputimer       = scripting.addModule("/driverlib/cputimer.js", {}, false);
const cputimer1      = cputimer.addInstance();
const dac            = scripting.addModule("/driverlib/dac.js", {}, false);
const dac1           = dac.addInstance();
const dac2           = dac.addInstance();
const device_support = scripting.addModule("/driverlib/device_support.js");
const epwm           = scripting.addModule("/driverlib/epwm.js", {}, false);
const epwm1          = epwm.addInstance();
const epwm2          = epwm.addInstance();
const epwm3          = epwm.addInstance();
const epwm4          = epwm.addInstance();
const epwm5          = epwm.addInstance();
const epwm6          = epwm.addInstance();
const eqep           = scripting.addModule("/driverlib/eqep.js", {}, false);
const eqep1          = eqep.addInstance();
const eqep2          = eqep.addInstance();
const gpio           = scripting.addModule("/driverlib/gpio.js", {}, false);
const gpio1          = gpio.addInstance();
const gpio2          = gpio.addInstance();
const gpio3          = gpio.addInstance();
const gpio4          = gpio.addInstance();
const gpio5          = gpio.addInstance();
const gpio6          = gpio.addInstance();
const gpio7          = gpio.addInstance();
const gpio8          = gpio.addInstance();
const gpio9          = gpio.addInstance();
const i2c            = scripting.addModule("/driverlib/i2c.js", {}, false);
const i2c1           = i2c.addInstance();
const other          = scripting.addModule("/driverlib/other.js", {}, false);
const other1         = other.addInstance();
const sci            = scripting.addModule("/driverlib/sci.js", {}, false);
const sci1           = sci.addInstance();
const sci2           = sci.addInstance();
const spi            = scripting.addModule("/driverlib/spi.js", {}, false);
const spi1           = spi.addInstance();
const spi2           = spi.addInstance();

/**
 * Write custom configuration values to the imported modules.
 */
adc1.$name                          = "IRIS_ADCA";
adc1.adcClockPrescaler              = "ADC_CLK_DIV_2_0";
adc1.enabledInts                    = ["ADC_INT_NUMBER1"];
adc1.enableInterrupt1               = true;
adc1.enableInterrupt1ContinuousMode = true;
adc1.registerInterrupts             = ["1"];
adc1.soc0SampleWindow               = 9;
adc1.soc2SampleWindow               = 9;
adc1.soc1SampleWindow               = 9;
adc1.soc0Trigger                    = "ADC_TRIGGER_EPWM1_SOCA";
adc1.soc0IndependentNameMode        = true;
adc1.soc1IndependentNameMode        = true;
adc1.soc2Trigger                    = "ADC_TRIGGER_EPWM1_SOCA";
adc1.soc1Trigger                    = "ADC_TRIGGER_EPWM1_SOCA";
adc1.soc2IndependentNameMode        = true;
adc1.soc0Name                       = "INV_IU";
adc1.soc0Channel                    = "ADC_CH_ADCIN2";
adc1.soc1Name                       = "INV_IA";
adc1.soc1Channel                    = "ADC_CH_ADCIN8";
adc1.soc2Name                       = "INV_UA";
adc1.soc2Channel                    = "ADC_CH_ADCIN10";
adc1.soc3Name                       = "INV_UU";
adc1.soc3SampleWindow               = 9;
adc1.soc3Trigger                    = "ADC_TRIGGER_EPWM1_SOCA";
adc1.soc3IndependentNameMode        = true;
adc1.soc3Channel                    = "ADC_CH_ADCIN6";
adc1.enabledSOCs                    = ["ADC_SOC_NUMBER0","ADC_SOC_NUMBER1","ADC_SOC_NUMBER2","ADC_SOC_NUMBER3","ADC_SOC_NUMBER4"];
adc1.soc4Name                       = "INV_VBUS";
adc1.soc4Channel                    = "ADC_CH_ADCIN11";
adc1.soc4Trigger                    = "ADC_TRIGGER_EPWM1_SOCA";
adc1.soc4SampleWindow               = 9;
adc1.soc4IndependentNameMode        = true;
adc1.adcInt1.interruptHandler       = "MainISR";
adc1.adcInt1.enableInterrupt        = true;

adc2.$name                   = "IRIS_ADCB";
adc2.adcBase                 = "ADCB_BASE";
adc2.adcClockPrescaler       = "ADC_CLK_DIV_2_0";
adc2.soc0SampleWindow        = 9;
adc2.soc1SampleWindow        = 9;
adc2.soc0Trigger             = "ADC_TRIGGER_EPWM1_SOCA";
adc2.soc1Trigger             = "ADC_TRIGGER_EPWM1_SOCA";
adc2.soc1IndependentNameMode = true;
adc2.soc0IndependentNameMode = true;
adc2.soc2SampleWindow        = 9;
adc2.soc2IndependentNameMode = true;
adc2.soc2Trigger             = "ADC_TRIGGER_EPWM1_SOCA";
adc2.soc0Name                = "INV_IV";
adc2.soc1Name                = "INV_IB";
adc2.soc2Name                = "INV_UB";
adc2.soc3Name                = "INV_UV";
adc2.soc3IndependentNameMode = true;
adc2.soc3SampleWindow        = 9;
adc2.soc0Channel             = "ADC_CH_ADCIN9";
adc2.soc1Channel             = "ADC_CH_ADCIN8";
adc2.soc3Channel             = "ADC_CH_ADCIN3";
adc2.soc3Trigger             = "ADC_TRIGGER_EPWM1_SOCA";
adc2.enabledSOCs             = ["ADC_SOC_NUMBER0","ADC_SOC_NUMBER1","ADC_SOC_NUMBER2","ADC_SOC_NUMBER3","ADC_SOC_NUMBER4"];
adc2.soc4Name                = "INV_IBUS";
adc2.soc4IndependentNameMode = true;
adc2.soc4Channel             = "ADC_CH_ADCIN12";
adc2.soc4Trigger             = "ADC_TRIGGER_EPWM1_SOCA";
adc2.soc4SampleWindow        = 9;

adc3.$name                   = "IRIS_ADCC";
adc3.adcBase                 = "ADCC_BASE";
adc3.adcClockPrescaler       = "ADC_CLK_DIV_2_0";
adc3.soc0SampleWindow        = 9;
adc3.soc1SampleWindow        = 9;
adc3.soc1Trigger             = "ADC_TRIGGER_EPWM1_SOCA";
adc3.soc0Trigger             = "ADC_TRIGGER_EPWM1_SOCA";
adc3.soc0IndependentNameMode = true;
adc3.soc1IndependentNameMode = true;
adc3.enabledSOCs             = ["ADC_SOC_NUMBER0","ADC_SOC_NUMBER1","ADC_SOC_NUMBER2","ADC_SOC_NUMBER3"];
adc3.soc1Name                = "INV_IC";
adc3.soc2Name                = "INV_UC";
adc3.soc3Name                = "INV_UW";
adc3.soc3IndependentNameMode = true;
adc3.soc2IndependentNameMode = true;
adc3.soc2SampleWindow        = 9;
adc3.soc3SampleWindow        = 9;
adc3.soc3Trigger             = "ADC_TRIGGER_EPWM1_SOCA";
adc3.soc2Trigger             = "ADC_TRIGGER_EPWM1_SOCA";
adc3.soc0Channel             = "ADC_CH_ADCIN4";
adc3.soc1Channel             = "ADC_CH_ADCIN8";
adc3.soc2Channel             = "ADC_CH_ADCIN14";
adc3.soc3Channel             = "ADC_CH_ADCIN6";
adc3.soc0Name                = "INV_IW";

fsi1.$name               = "myBoardFSI0";
fsi1.fsiRx.d0Qual.$name  = "myGPIOQUAL12";
fsi1.fsiRx.d1Qual.$name  = "myGPIOQUAL13";
fsi1.fsiRx.clkQual.$name = "myGPIOQUAL14";
fsi1.fsiTx.useCase       = "FSI TX Dual Dataline";
fsi1.fsiTx.d0Qual.$name  = "myGPIOQUAL15";
fsi1.fsiTx.d1Qual.$name  = "myGPIOQUAL16";
fsi1.fsiTx.clkQual.$name = "myGPIOQUAL17";

can1.$name                   = "IRIS_CAN";
can1.bitRate                 = "1000000";
can1.enableInterrupt         = true;
can1.registerInterrupts      = true;
can1.interruptFlags          = ["CAN_INT_IE0"];
can1.interruptLine           = ["CAN_GLOBAL_INT_CANINT0"];
can1.enableAutoBusOn         = true;
can1.AutoBusOnTimer          = 128;
can1.msgObjsUsed             = [1,2,3,4,5,6,7,8,9,10];
can1.can.$assign             = "CANA";
can1.can.can_rxPin.$assign   = "GPIO30";
can1.can.can_txPin.$assign   = "GPIO31";
can1.can0Int.enableInterrupt = true;
can1.msgObj1.$name           = "msgObj0";
can1.msgObj1.flags           = ["CAN_MSG_OBJ_RX_INT_ENABLE"];
can1.msgObj1.msgID           = 257;
can1.msgObj2.$name           = "msgObj1";
can1.msgObj2.msgID           = 258;
can1.msgObj2.flags           = ["CAN_MSG_OBJ_RX_INT_ENABLE"];
can1.msgObj3.$name           = "msgObj2";
can1.msgObj3.msgID           = 259;
can1.msgObj3.flags           = ["CAN_MSG_OBJ_RX_INT_ENABLE"];
can1.msgObj4.$name           = "msgObj3";
can1.msgObj4.msgID           = 513;
can1.msgObj4.msgType         = "CAN_MSG_OBJ_TYPE_TX";
can1.msgObj4.msgLen          = 8;
can1.msgObj4.intLine         = "1";
can1.msgObj5.$name           = "msgObj4";
can1.msgObj5.msgID           = 514;
can1.msgObj5.msgType         = "CAN_MSG_OBJ_TYPE_TX";
can1.msgObj5.msgLen          = 8;
can1.msgObj5.intLine         = "1";
can1.msgObj6.$name           = "msgObj5";
can1.msgObj6.msgID           = 515;
can1.msgObj6.msgType         = "CAN_MSG_OBJ_TYPE_TX";
can1.msgObj6.msgLen          = 8;
can1.msgObj6.intLine         = "1";
can1.msgObj7.$name           = "msgObj7";
can1.msgObj7.msgID           = 516;
can1.msgObj7.msgType         = "CAN_MSG_OBJ_TYPE_TX";
can1.msgObj7.msgLen          = 8;
can1.msgObj7.intLine         = "1";
can1.msgObj8.$name           = "msgObj6";
can1.msgObj8.msgID           = 517;
can1.msgObj8.msgType         = "CAN_MSG_OBJ_TYPE_TX";
can1.msgObj8.msgLen          = 8;
can1.msgObj8.intLine         = "1";
can1.msgObj9.$name           = "msgObj8";
can1.msgObj9.msgID           = 518;
can1.msgObj9.msgType         = "CAN_MSG_OBJ_TYPE_TX";
can1.msgObj9.msgLen          = 8;
can1.msgObj9.intLine         = "1";
can1.msgObj10.$name          = "msgObj9";
can1.msgObj10.msgID          = 519;
can1.msgObj10.msgType        = "CAN_MSG_OBJ_TYPE_TX";
can1.msgObj10.msgLen         = 8;
can1.msgObj10.intLine        = "1";

const divider2       = system.clockTree["LOSPCP"];
divider2.divideValue = 1;

const divider4       = system.clockTree["PLL_ODIV"];
divider4.divideValue = 2;

const divider5       = system.clockTree["PLL_REFDIV"];
divider5.divideValue = 4;

const multiplier1         = system.clockTree["PLL_IMULT"];
multiplier1.multiplyValue = 80;

const mux3       = system.clockTree["OSCCLKSRCSEL"];
mux3.inputSelect = "X1_XTAL";

const mux5       = system.clockTree["XTAL_OR_X1"];
mux5.inputSelect = "X1";

const pinFunction2     = system.clockTree["X1"];
pinFunction2.XTAL_Freq = 12;

const pinFunction3     = system.clockTree["XTAL"];
pinFunction3.XTAL_Freq = 12;

cputimer1.$name       = "myCPUTIMER0";
cputimer1.timerPeriod = 1000;

dac1.$name            = "IRIS_DACA";
dac1.enableOutput     = true;
dac1.referenceVoltage = "DAC_REF_ADC_VREFHI";
dac1.shadowValue      = 500;

dac2.$name            = "IRIS_DACB";
dac2.dacBase          = "DACB_BASE";
dac2.enableOutput     = true;
dac2.referenceVoltage = "DAC_REF_ADC_VREFHI";
dac2.shadowValue      = 500;

dac1.analog                                      = analog1;
dac2.analog                                      = analog1;
analog1.useCase                                  = "CUSTOM";
adc1.analog                                      = analog1;
adc2.analog                                      = analog1;
adc3.analog                                      = analog1;
analog1.useInterfacePins                         = ["A0/B15/C15/DACA_OUT","A1/B7/DACB_OUT","A10/B1/C10","A11/B10/C0","A12, C5","A14/B14/C4","A2/B6/C9","A3, C7/B9","A4/B8","A5","A6","A8","A9","B0/C11","B11","B2/C6","B3/VDAC","B4/C8","B5","C1","C14","C2/B12","C3/A7"];
analog1.$name                                    = "IRIS_ANALOG_PinMux";
analog1.analog.$assign                           = "ANALOG";
analog1.analog["a0/b15/c15/daca_outPin"].$assign = "A0/B15/C15/DACA_OUT";
analog1.analog["a1/b7/dacb_outPin"].$assign      = "A1/B7/DACB_OUT";
analog1.analog["a10/b1/c10Pin"].$assign          = "A10/B1/C10";
analog1.analog["a11/b10/c0Pin"].$assign          = "A11/B10/C0";
analog1.analog["a12, c5Pin"].$assign             = "A12, C5";
analog1.analog["a14/b14/c4Pin"].$assign          = "A14/B14/C4";
analog1.analog["a2/b6/c9Pin"].$assign            = "A2/B6/C9";
analog1.analog["a3, c7/b9Pin"].$assign           = "A3, C7/B9";
analog1.analog["a4/b8Pin"].$assign               = "A4/B8";
analog1.analog.a5Pin.$assign                     = "A5";
analog1.analog.a6Pin.$assign                     = "A6";
analog1.analog.a8Pin.$assign                     = "A8";
analog1.analog.a9Pin.$assign                     = "A9";
analog1.analog["b0/c11Pin"].$assign              = "B0/C11";
analog1.analog.b11Pin.$assign                    = "B11";
analog1.analog["b2/c6Pin"].$assign               = "B2/C6";
analog1.analog["b3/vdacPin"].$assign             = "B3/VDAC";
analog1.analog["b4/c8Pin"].$assign               = "B4/C8";
analog1.analog.b5Pin.$assign                     = "B5";
analog1.analog.c1Pin.$assign                     = "C1";
analog1.analog.c14Pin.$assign                    = "C14";
analog1.analog["c2/b12Pin"].$assign              = "C2/B12";
analog1.analog["c3/a7Pin"].$assign               = "C3/A7";

epwm1.$name                                                      = "IRIS_EPWM1";
epwm1.epwmEventTrigger_EPWM_SOC_A_triggerEnable                  = true;
epwm1.epwmEventTrigger_EPWM_SOC_A_triggerSource                  = "EPWM_SOC_TBCTR_PERIOD";
epwm1.epwmTimebase_periodLoadEvent                               = "EPWM_SHADOW_LOAD_MODE_COUNTER_SYNC";
epwm1.epwmTimebase_counterMode                                   = "EPWM_COUNTER_MODE_UP_DOWN";
epwm1.epwmTimebase_counterModeAfterSync                          = "EPWM_COUNT_MODE_UP_AFTER_SYNC";
epwm1.epwmCounterCompare_cmpA                                    = 3000;
epwm1.epwmActionQualifier_EPWM_AQ_OUTPUT_A_ON_TIMEBASE_UP_CMPA   = "EPWM_AQ_OUTPUT_HIGH";
epwm1.epwmActionQualifier_EPWM_AQ_OUTPUT_A_ON_TIMEBASE_DOWN_CMPA = "EPWM_AQ_OUTPUT_LOW";
epwm1.epwmDeadband_enableRED                                     = true;
epwm1.epwmDeadband_enableFED                                     = true;
epwm1.epwmTimebase_hsClockDiv                                    = "EPWM_HSCLOCK_DIVIDER_1";
epwm1.epwmTimebase_phaseEnable                                   = true;
epwm1.epwmTimebase_syncOutPulseMode                              = ["EPWM_SYNC_OUT_PULSE_ON_CNTR_ZERO"];
epwm1.epwmCounterCompare_cmpAGld                                 = true;
epwm1.epwmCounterCompare_cmpBGld                                 = true;
epwm1.epwmEventTrigger_enableInterrupt                           = true;
epwm1.epwmEventTrigger_EPWM_SOC_A_triggerEventPrescalar          = "1";
epwm1.epwmEventTrigger_interruptEventCount                       = "1";
epwm1.epwmActionQualifier_EPWM_AQ_OUTPUT_A_gld                   = true;
epwm1.epwmActionQualifier_EPWM_AQ_OUTPUT_A_shadowMode            = true;
epwm1.epwmCounterCompare_cmpB                                    = 1500;
epwm1.epwmDeadband_polarityFED                                   = "EPWM_DB_POLARITY_ACTIVE_LOW";
epwm1.epwmEventTrigger_interruptSource                           = "EPWM_INT_TBCTR_PERIOD";
epwm1.epwmTimebase_period                                        = 6000;
epwm1.epwmDeadband_delayRED                                      = 50;
epwm1.epwmDeadband_delayFED                                      = 50;

epwm2.$name                                                      = "IRIS_EPWM2";
epwm2.copyFrom                                                   = "IRIS_EPWM1";
epwm2.epwmTimebase_hsClockDiv                                    = "EPWM_HSCLOCK_DIVIDER_1";
epwm2.epwmTimebase_periodLoadEvent                               = "EPWM_SHADOW_LOAD_MODE_COUNTER_SYNC";
epwm2.epwmTimebase_period                                        = 6000;
epwm2.epwmTimebase_counterMode                                   = "EPWM_COUNTER_MODE_UP_DOWN";
epwm2.epwmTimebase_counterModeAfterSync                          = "EPWM_COUNT_MODE_UP_AFTER_SYNC";
epwm2.epwmTimebase_phaseEnable                                   = true;
epwm2.epwmTimebase_syncOutPulseMode                              = ["EPWM_SYNC_OUT_PULSE_ON_CNTR_ZERO"];
epwm2.epwmCounterCompare_cmpA                                    = 3000;
epwm2.epwmCounterCompare_cmpAGld                                 = true;
epwm2.epwmCounterCompare_cmpB                                    = 1500;
epwm2.epwmCounterCompare_cmpBGld                                 = true;
epwm2.epwmActionQualifier_EPWM_AQ_OUTPUT_A_gld                   = true;
epwm2.epwmActionQualifier_EPWM_AQ_OUTPUT_A_shadowMode            = true;
epwm2.epwmActionQualifier_EPWM_AQ_OUTPUT_A_ON_TIMEBASE_UP_CMPA   = "EPWM_AQ_OUTPUT_HIGH";
epwm2.epwmActionQualifier_EPWM_AQ_OUTPUT_A_ON_TIMEBASE_DOWN_CMPA = "EPWM_AQ_OUTPUT_LOW";
epwm2.epwmDeadband_polarityFED                                   = "EPWM_DB_POLARITY_ACTIVE_LOW";
epwm2.epwmDeadband_enableRED                                     = true;
epwm2.epwmDeadband_enableFED                                     = true;
epwm2.epwmEventTrigger_enableInterrupt                           = true;
epwm2.epwmEventTrigger_interruptSource                           = "EPWM_INT_TBCTR_PERIOD";
epwm2.epwmEventTrigger_interruptEventCount                       = "1";
epwm2.epwmEventTrigger_EPWM_SOC_A_triggerEnable                  = true;
epwm2.epwmEventTrigger_EPWM_SOC_A_triggerSource                  = "EPWM_SOC_TBCTR_PERIOD";
epwm2.epwmEventTrigger_EPWM_SOC_A_triggerEventPrescalar          = "1";
epwm2.epwmDeadband_delayRED                                      = 50;
epwm2.epwmDeadband_delayFED                                      = 50;
epwm2.epwm.$assign                                               = "EPWM1";
epwm2.epwm.epwm_aPin.$assign                                     = "GPIO0";
epwm2.epwm.epwm_bPin.$assign                                     = "GPIO1";

epwm3.$name                                                      = "IRIS_EPWM3";
epwm3.copyFrom                                                   = "IRIS_EPWM1";
epwm3.epwmTimebase_hsClockDiv                                    = "EPWM_HSCLOCK_DIVIDER_1";
epwm3.epwmTimebase_periodLoadEvent                               = "EPWM_SHADOW_LOAD_MODE_COUNTER_SYNC";
epwm3.epwmTimebase_period                                        = 6000;
epwm3.epwmTimebase_counterMode                                   = "EPWM_COUNTER_MODE_UP_DOWN";
epwm3.epwmTimebase_counterModeAfterSync                          = "EPWM_COUNT_MODE_UP_AFTER_SYNC";
epwm3.epwmTimebase_phaseEnable                                   = true;
epwm3.epwmTimebase_syncOutPulseMode                              = ["EPWM_SYNC_OUT_PULSE_ON_CNTR_ZERO"];
epwm3.epwmCounterCompare_cmpA                                    = 3000;
epwm3.epwmCounterCompare_cmpAGld                                 = true;
epwm3.epwmCounterCompare_cmpB                                    = 1500;
epwm3.epwmCounterCompare_cmpBGld                                 = true;
epwm3.epwmActionQualifier_EPWM_AQ_OUTPUT_A_gld                   = true;
epwm3.epwmActionQualifier_EPWM_AQ_OUTPUT_A_shadowMode            = true;
epwm3.epwmActionQualifier_EPWM_AQ_OUTPUT_A_ON_TIMEBASE_UP_CMPA   = "EPWM_AQ_OUTPUT_HIGH";
epwm3.epwmActionQualifier_EPWM_AQ_OUTPUT_A_ON_TIMEBASE_DOWN_CMPA = "EPWM_AQ_OUTPUT_LOW";
epwm3.epwmDeadband_polarityFED                                   = "EPWM_DB_POLARITY_ACTIVE_LOW";
epwm3.epwmDeadband_enableRED                                     = true;
epwm3.epwmDeadband_enableFED                                     = true;
epwm3.epwmEventTrigger_enableInterrupt                           = true;
epwm3.epwmEventTrigger_interruptSource                           = "EPWM_INT_TBCTR_PERIOD";
epwm3.epwmEventTrigger_interruptEventCount                       = "1";
epwm3.epwmEventTrigger_EPWM_SOC_A_triggerEnable                  = true;
epwm3.epwmEventTrigger_EPWM_SOC_A_triggerSource                  = "EPWM_SOC_TBCTR_PERIOD";
epwm3.epwmEventTrigger_EPWM_SOC_A_triggerEventPrescalar          = "1";
epwm3.epwmDeadband_delayRED                                      = 50;
epwm3.epwmDeadband_delayFED                                      = 50;
epwm3.epwm.$assign                                               = "EPWM4";
epwm3.epwm.epwm_aPin.$assign                                     = "GPIO22";
epwm3.epwm.epwm_bPin.$assign                                     = "GPIO7";

epwm4.$name                                                      = "IRIS_EPWM4";
epwm4.copyUse                                                    = true;
epwm4.copyFrom                                                   = "IRIS_EPWM2";
epwm4.epwmTimebase_hsClockDiv                                    = "EPWM_HSCLOCK_DIVIDER_1";
epwm4.epwmTimebase_periodLoadEvent                               = "EPWM_SHADOW_LOAD_MODE_COUNTER_SYNC";
epwm4.epwmTimebase_period                                        = 6000;
epwm4.epwmTimebase_counterMode                                   = "EPWM_COUNTER_MODE_UP_DOWN";
epwm4.epwmTimebase_counterModeAfterSync                          = "EPWM_COUNT_MODE_UP_AFTER_SYNC";
epwm4.epwmTimebase_phaseEnable                                   = true;
epwm4.epwmTimebase_syncOutPulseMode                              = ["EPWM_SYNC_OUT_PULSE_ON_CNTR_ZERO"];
epwm4.epwmCounterCompare_cmpA                                    = 3000;
epwm4.epwmCounterCompare_cmpAGld                                 = true;
epwm4.epwmCounterCompare_cmpB                                    = 1500;
epwm4.epwmCounterCompare_cmpBGld                                 = true;
epwm4.epwmActionQualifier_EPWM_AQ_OUTPUT_A_gld                   = true;
epwm4.epwmActionQualifier_EPWM_AQ_OUTPUT_A_shadowMode            = true;
epwm4.epwmActionQualifier_EPWM_AQ_OUTPUT_A_ON_TIMEBASE_UP_CMPA   = "EPWM_AQ_OUTPUT_HIGH";
epwm4.epwmActionQualifier_EPWM_AQ_OUTPUT_A_ON_TIMEBASE_DOWN_CMPA = "EPWM_AQ_OUTPUT_LOW";
epwm4.epwmDeadband_polarityFED                                   = "EPWM_DB_POLARITY_ACTIVE_LOW";
epwm4.epwmDeadband_enableRED                                     = true;
epwm4.epwmDeadband_delayRED                                      = 200;
epwm4.epwmDeadband_enableFED                                     = true;
epwm4.epwmDeadband_delayFED                                      = 200;
epwm4.epwmEventTrigger_enableInterrupt                           = true;
epwm4.epwmEventTrigger_interruptSource                           = "EPWM_INT_TBCTR_PERIOD";
epwm4.epwmEventTrigger_interruptEventCount                       = "1";
epwm4.epwmEventTrigger_EPWM_SOC_A_triggerEnable                  = true;
epwm4.epwmEventTrigger_EPWM_SOC_A_triggerSource                  = "EPWM_SOC_TBCTR_PERIOD";
epwm4.epwmEventTrigger_EPWM_SOC_A_triggerEventPrescalar          = "1";
epwm4.epwm.$assign                                               = "EPWM3";
epwm4.epwm.epwm_aPin.$assign                                     = "GPIO4";
epwm4.epwm.epwm_bPin.$assign                                     = "GPIO5";

epwm5.$name                  = "IRIS_EPWM5";
epwm5.epwm.$assign           = "EPWM8";
epwm5.epwm.epwm_aPin.$assign = "GPIO14";
epwm5.epwm.epwm_bPin.$assign = "GPIO15";

epwm6.$name                  = "IRIS_EPWM6";
epwm6.epwm.$assign           = "EPWM7";
epwm6.epwm.epwm_aPin.$assign = "GPIO28";
epwm6.epwm.epwm_bPin.$assign = "GPIO29";

eqep1.$name                      = "IRIS_EQEP1";
eqep1.useCase                    = "CUSTOM";
eqep1.useInterfacePins           = ["EQEP#_A","EQEP#_B","EQEP#_INDEX"];
eqep1.eqep.$assign               = "EQEP1";
eqep1.eqep.eqep_aPin.$assign     = "B5, GPIO20";
eqep1.eqep.eqep_bPin.$assign     = "B11, GPIO21";
eqep1.eqep.eqep_indexPin.$assign = "GPIO13";

eqep2.$name                      = "IRIS_EQEP2";
eqep2.useCase                    = "CUSTOM";
eqep2.useInterfacePins           = ["EQEP#_A","EQEP#_B","EQEP#_INDEX"];
eqep2.eqep.$assign               = "EQEP2";
eqep2.eqep.eqep_aPin.$assign     = "GPIO24";
eqep2.eqep.eqep_bPin.$assign     = "GPIO33";
eqep2.eqep.eqep_indexPin.$assign = "GPIO26";

gpio1.$name           = "IRIS_GPIO1";
gpio1.direction       = "GPIO_DIR_MODE_OUT";
gpio1.gpioPin.$assign = "GPIO58";

gpio2.$name           = "IRIS_GPIO2";
gpio2.direction       = "GPIO_DIR_MODE_OUT";
gpio2.gpioPin.$assign = "GPIO23";

gpio3.$name           = "IRIS_GPIO3";
gpio3.direction       = "GPIO_DIR_MODE_OUT";
gpio3.gpioPin.$assign = "GPIO40";

gpio4.$name           = "IRIS_GPIO4";
gpio4.gpioPin.$assign = "GPIO44";

gpio5.$name           = "IRIS_GPIO5";
gpio5.gpioPin.$assign = "GPIO34";

gpio6.$name           = "IRIS_GPIO6";
gpio6.gpioPin.$assign = "GPIO47";

gpio7.$name           = "IRIS_LED1";
gpio7.direction       = "GPIO_DIR_MODE_OUT";
gpio7.gpioPin.$assign = "GPIO61";

gpio8.$name           = "IRIS_LED2";
gpio8.direction       = "GPIO_DIR_MODE_OUT";
gpio8.gpioPin.$assign = "GPIO59";

gpio9.$name           = "IRIS_GPIO_SPI_RST";
gpio9.direction       = "GPIO_DIR_MODE_OUT";
gpio9.gpioPin.$assign = "GPIO55";

i2c1.$name                  = "IRIS_IIC";
i2c1.i2c.$assign            = "I2CA";
i2c1.i2c.i2c_sdaPin.$assign = "GPIO56";
i2c1.i2c.i2c_sclPin.$assign = "GPIO57";

other1.useCase                   = "CUSTOM";
other1.useInterfacePins          = ["ADCSOCAO","SYNCOUT","TDI","TDO","X1","XCLKOUT","XRSn"];
other1.$name                     = "OTHER_PIN_DEFINITION";
other1.other.$assign             = "OTHER";
other1.other.adcsocaoPin.$assign = "GPIO8";
other1.other.syncoutPin.$assign  = "GPIO6";
other1.other.xclkoutPin.$assign  = "GPIO18, X2";
other1.other.tdoPin.$assign      = "GPIO37/TDO";
other1.other.tdiPin.$assign      = "GPIO35/TDI";
other1.other.x1Pin.$assign       = "GPIO19, X1";

sci1.enabledFIFOInterrupts      = ["SCI_INT_RXFF"];
sci1.selectRegisteredInterrupts = ["registerRxInt"];
sci1.$name                      = "IRIS_UART_RS232";
sci1.sci.$assign                = "SCIA";
sci1.sci.sci_rxPin.$assign      = "GPIO9";
sci1.sci.sci_txPin.$assign      = "GPIO48";
sci1.rxQual.$name               = "myGPIOQUAL0";
sci1.txQual.$name               = "myGPIOQUAL1";

sci2.$name                      = "IRIS_UART_USB";
sci2.enabledFIFOInterrupts      = ["SCI_INT_RXFF"];
sci2.selectRegisteredInterrupts = ["registerRxInt"];
sci2.enabledErrorInterrupts     = ["SCI_INT_FE","SCI_INT_OE"];
sci2.rxFifo                     = "SCI_FIFO_RX12";
sci2.baudRates                  = 921600;
sci2.sci.$assign                = "SCIB";
sci2.sci.sci_rxPin.$assign      = "GPIO41";
sci2.sci.sci_txPin.$assign      = "GPIO10";
sci2.rxQual.$name               = "myGPIOQUAL6";
sci2.txQual.$name               = "myGPIOQUAL7";
sci2.sciRXInt.enableInterrupt   = true;

spi1.$name          = "IRIS_SPI_FPGA_BRIDGE";
spi1.emulationMode  = "SPI_EMULATION_FREE_RUN";
spi1.mode           = "SPI_MODE_CONTROLLER";
spi1.useInterrupts  = false;
spi1.useHSMode      = true;
spi1.bitRate        = 15000000;
spi1.spi.$assign    = "SPIA";
spi1.picoQual.$name = "myGPIOQUAL2";
spi1.pociQual.$name = "myGPIOQUAL3";
spi1.clkQual.$name  = "myGPIOQUAL4";
spi1.pteQual.$name  = "myGPIOQUAL5";

spi2.$name                   = "IRIS_SPI_OUT";
spi2.spi.spi_picoPin.$assign = "GPIO60";
spi2.spi.spi_pociPin.$assign = "GPIO25";
spi2.spi.spi_clkPin.$assign  = "GPIO32";
spi2.spi.spi_ptePin.$assign  = "GPIO27";
spi2.picoQual.$name          = "myGPIOQUAL8";
spi2.pociQual.$name          = "myGPIOQUAL9";
spi2.clkQual.$name           = "myGPIOQUAL10";
spi2.pteQual.$name           = "myGPIOQUAL11";

/**
 * Pinmux solution for unlocked pins/peripherals. This ensures that minor changes to the automatic solver in a future
 * version of the tool will not impact the pinmux you originally saw.  These lines can be completely deleted in order to
 * re-solve from scratch.
 */
fsi1.fsiRx.fsirx.$suggestSolution              = "FSIRXA";
fsi1.fsiRx.fsirx.fsirx_d0Pin.$suggestSolution  = "GPIO52";
fsi1.fsiRx.fsirx.fsirx_d1Pin.$suggestSolution  = "GPIO53";
fsi1.fsiRx.fsirx.fsirx_clkPin.$suggestSolution = "GPIO54";
fsi1.fsiTx.fsitx.$suggestSolution              = "FSITXA";
fsi1.fsiTx.fsitx.fsitx_d0Pin.$suggestSolution  = "GPIO49";
fsi1.fsiTx.fsitx.fsitx_d1Pin.$suggestSolution  = "GPIO50";
fsi1.fsiTx.fsitx.fsitx_clkPin.$suggestSolution = "GPIO51";
epwm1.epwm.$suggestSolution                    = "EPWM2";
epwm1.epwm.epwm_aPin.$suggestSolution          = "GPIO2";
epwm1.epwm.epwm_bPin.$suggestSolution          = "GPIO3";
spi1.spi.spi_picoPin.$suggestSolution          = "GPIO16";
spi1.spi.spi_pociPin.$suggestSolution          = "GPIO17";
spi1.spi.spi_clkPin.$suggestSolution           = "GPIO12";
spi1.spi.spi_ptePin.$suggestSolution           = "GPIO11";
spi2.spi.$suggestSolution                      = "SPIB";
