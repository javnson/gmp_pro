/**
 * These arguments were used when this file was generated. They will be automatically applied on subsequent loads
 * via the GUI or CLI. Run CLI with '--help' for additional information on how to override these arguments.
 * @cliArgs --device "F28003x" --part "F28003x_100PZ" --package "100PZ" --context "system" --product "gmp_pro@1.00.00.05" --product "C2000WARE@5.03.00.00"
 * @v2CliArgs --device "TMS320F280039C" --package "100PZ" --context "system" --product "gmp_pro@1.00.00.05" --product "C2000WARE@5.03.00.00"
 * @versions {"tool":"1.21.0+3721"}
 */

/**
 * Import the modules used in this configuration.
 */
const adc            = scripting.addModule("/driverlib/adc.js", {}, false);
const adc1           = adc.addInstance();
const adc2           = adc.addInstance();
const adc3           = adc.addInstance();
const analog         = scripting.addModule("/driverlib/analog.js", {}, false);
const analog1        = analog.addInstance();
const can            = scripting.addModule("/driverlib/can.js", {}, false);
const can1           = can.addInstance();
const dac            = scripting.addModule("/driverlib/dac.js", {}, false);
const dac1           = dac.addInstance();
const dac2           = dac.addInstance();
const device_support = scripting.addModule("/driverlib/device_support.js");
const epwm           = scripting.addModule("/driverlib/epwm.js", {}, false);
const epwm1          = epwm.addInstance();
const epwm2          = epwm.addInstance();
const epwm3          = epwm.addInstance();
const epwm4          = epwm.addInstance();
const epwm5          = epwm.addInstance();
const epwm6          = epwm.addInstance();
const eqep           = scripting.addModule("/driverlib/eqep.js", {}, false);
const eqep1          = eqep.addInstance();
const eqep2          = eqep.addInstance();
const gpio           = scripting.addModule("/driverlib/gpio.js", {}, false);
const gpio1          = gpio.addInstance();
const gpio2          = gpio.addInstance();
const gpio3          = gpio.addInstance();
const gpio4          = gpio.addInstance();
const sci            = scripting.addModule("/driverlib/sci.js", {}, false);
const sci1           = sci.addInstance();

/**
 * Write custom configuration values to the imported modules.
 */
adc1.adcClockPrescaler       = "ADC_CLK_DIV_2_0";
adc1.adcBase                 = "ADCB_BASE";
adc1.enabledSOCs             = ["ADC_SOC_NUMBER0","ADC_SOC_NUMBER1","ADC_SOC_NUMBER2","ADC_SOC_NUMBER3","ADC_SOC_NUMBER4"];
adc1.soc0Name                = "J7_IV";
adc1.soc0IndependentNameMode = true;
adc1.soc0Channel             = "ADC_CH_ADCIN5";
adc1.soc0Trigger             = "ADC_TRIGGER_EPWM1_SOCA";
adc1.soc0SampleWindow        = 9;
adc1.soc1Name                = "J3_IV";
adc1.soc1IndependentNameMode = true;
adc1.soc1Channel             = "ADC_CH_ADCIN12";
adc1.soc1Trigger             = "ADC_TRIGGER_EPWM1_SOCA";
adc1.soc1SampleWindow        = 9;
adc1.soc2Name                = "J7_VW";
adc1.soc2IndependentNameMode = true;
adc1.soc2Trigger             = "ADC_TRIGGER_EPWM1_SOCA";
adc1.soc2Channel             = "ADC_CH_ADCIN8";
adc1.soc2SampleWindow        = 9;
adc1.soc3Name                = "J3_VV";
adc1.soc3IndependentNameMode = true;
adc1.soc3Channel             = "ADC_CH_ADCIN9";
adc1.soc3Trigger             = "ADC_TRIGGER_EPWM1_SOCA";
adc1.soc3SampleWindow        = 9;
adc1.soc4Name                = "J7_VDC";
adc1.soc4Channel             = "ADC_CH_ADCIN11";
adc1.soc4Trigger             = "ADC_TRIGGER_EPWM1_SOCA";
adc1.soc4SampleWindow        = 9;
adc1.soc4IndependentNameMode = true;
adc1.$name                   = "IRIS_ADCB";

adc2.adcClockPrescaler              = "ADC_CLK_DIV_2_0";
adc2.enabledSOCs                    = ["ADC_SOC_NUMBER0","ADC_SOC_NUMBER1","ADC_SOC_NUMBER2","ADC_SOC_NUMBER3","ADC_SOC_NUMBER4"];
adc2.soc0Name                       = "J3_IU";
adc2.soc0IndependentNameMode        = true;
adc2.soc0Channel                    = "ADC_CH_ADCIN11";
adc2.soc0SampleWindow               = 9;
adc2.soc0Trigger                    = "ADC_TRIGGER_EPWM1_SOCA";
adc2.soc1Name                       = "J7_IW";
adc2.soc1SampleWindow               = 9;
adc2.soc1Channel                    = "ADC_CH_ADCIN12";
adc2.soc1Trigger                    = "ADC_TRIGGER_EPWM1_SOCA";
adc2.soc2Name                       = "J7_VV";
adc2.soc2SampleWindow               = 9;
adc2.soc2Trigger                    = "ADC_TRIGGER_EPWM1_SOCA";
adc2.soc3Name                       = "J3_VU";
adc2.soc3IndependentNameMode        = true;
adc2.soc3Channel                    = "ADC_CH_ADCIN2";
adc2.soc3Trigger                    = "ADC_TRIGGER_EPWM1_SOCA";
adc2.soc3SampleWindow               = 9;
adc2.soc4Name                       = "J3_VDC";
adc2.soc4IndependentNameMode        = true;
adc2.soc4Channel                    = "ADC_CH_ADCIN6";
adc2.soc4SampleWindow               = 9;
adc2.soc4Trigger                    = "ADC_TRIGGER_EPWM1_SOCA";
adc2.soc2IndependentNameMode        = true;
adc2.soc1IndependentNameMode        = true;
adc2.enabledInts                    = ["ADC_INT_NUMBER1"];
adc2.enableInterrupt1               = true;
adc2.enableInterrupt1ContinuousMode = true;
adc2.registerInterrupts             = ["1"];
adc2.$name                          = "IRIS_ADCA";
adc2.adcInt1.enableInterrupt        = true;
adc2.adcInt1.interruptHandler       = "MainISR";

adc3.adcBase                 = "ADCC_BASE";
adc3.adcClockPrescaler       = "ADC_CLK_DIV_2_0";
adc3.enabledSOCs             = ["ADC_SOC_NUMBER0","ADC_SOC_NUMBER1","ADC_SOC_NUMBER2","ADC_SOC_NUMBER3"];
adc3.soc0Name                = "J3_IW";
adc3.soc0IndependentNameMode = true;
adc3.soc0Channel             = "ADC_CH_ADCIN3";
adc3.soc0Trigger             = "ADC_TRIGGER_EPWM1_SOCA";
adc3.soc0SampleWindow        = 9;
adc3.soc1Name                = "J7_IU";
adc3.soc1IndependentNameMode = true;
adc3.soc1Channel             = "ADC_CH_ADCIN8";
adc3.soc1Trigger             = "ADC_TRIGGER_EPWM1_SOCA";
adc3.soc1SampleWindow        = 9;
adc3.soc2Name                = "J7_VU";
adc3.soc2IndependentNameMode = true;
adc3.soc2Channel             = "ADC_CH_ADCIN10";
adc3.soc2Trigger             = "ADC_TRIGGER_EPWM1_SOCA";
adc3.soc2SampleWindow        = 9;
adc3.soc3Name                = "J3_VW";
adc3.soc3IndependentNameMode = true;
adc3.soc3Channel             = "ADC_CH_ADCIN4";
adc3.soc3Trigger             = "ADC_TRIGGER_EPWM1_SOCA";
adc3.soc3SampleWindow        = 9;
adc3.$name                   = "IRIS_ADCC";

can1.enableInterrupt         = true;
can1.registerInterrupts      = true;
can1.interruptFlags          = ["CAN_INT_IE0"];
can1.interruptLine           = ["CAN_GLOBAL_INT_CANINT0"];
can1.$name                   = "IRIS_CAN";
can1.msgObjsUsed             = [1,2,3,4,5,6,7,8,9,10];
can1.can.$assign             = "CANA";
can1.can.can_rxPin.$assign   = "GPIO5";
can1.can.can_txPin.$assign   = "GPIO4";
can1.can0Int.enableInterrupt = true;
can1.msgObj1.$name           = "msgObj0";
can1.msgObj1.msgID           = 257;
can1.msgObj2.$name           = "msgObj1";
can1.msgObj2.msgID           = 258;
can1.msgObj4.$name           = "msgObj2";
can1.msgObj4.msgID           = 513;
can1.msgObj4.msgType         = "CAN_MSG_OBJ_TYPE_TX";
can1.msgObj5.$name           = "msgObj3";
can1.msgObj5.msgID           = 514;
can1.msgObj5.msgType         = "CAN_MSG_OBJ_TYPE_TX";
can1.msgObj3.$name           = "msgObj4";
can1.msgObj3.msgID           = 259;
can1.msgObj6.$name           = "msgObj5";
can1.msgObj6.msgID           = 515;
can1.msgObj7.$name           = "msgObj6";
can1.msgObj7.msgID           = 516;
can1.msgObj7.msgType         = "CAN_MSG_OBJ_TYPE_TX";
can1.msgObj8.$name           = "msgObj7";
can1.msgObj8.msgID           = 517;
can1.msgObj8.msgType         = "CAN_MSG_OBJ_TYPE_TX";
can1.msgObj9.$name           = "msgObj8";
can1.msgObj9.msgID           = 518;
can1.msgObj9.msgType         = "CAN_MSG_OBJ_TYPE_TX";
can1.msgObj10.$name          = "msgObj9";
can1.msgObj10.msgID          = 519;
can1.msgObj10.msgType        = "CAN_MSG_OBJ_TYPE_TX";

const pinFunction3     = system.clockTree["XTAL"];
pinFunction3.XTAL_Freq = 12;

dac1.$name = "IRIS_DACA";

dac2.$name   = "IRIS_DACB";
dac2.dacBase = "DACB_BASE";

dac1.analog                                      = analog1;
dac2.analog                                      = analog1;
analog1.useCase                                  = "CUSTOM";
analog1.useInterfacePins                         = ["A0/B15/C15/DACA_OUT","A1/B7/DACB_OUT","A10/B1/C10","A11/B10/C0","A12, C5","A14/B14/C4","A2/B6/C9","A3, C7/B9","A4/B8","A5","A6","A8","A9","B0/C11","B11","B2/C6","B3/VDAC","B4/C8","B5","C1","C14","C2/B12","C3/A7"];
adc1.analog                                      = analog1;
adc2.analog                                      = analog1;
adc3.analog                                      = analog1;
analog1.$name                                    = "ANALOG_PinMux";
analog1.analog.$assign                           = "ANALOG";
analog1.analog["a0/b15/c15/daca_outPin"].$assign = "A0/B15/C15/DACA_OUT";
analog1.analog["a1/b7/dacb_outPin"].$assign      = "A1/B7/DACB_OUT";
analog1.analog["a10/b1/c10Pin"].$assign          = "A10/B1/C10";
analog1.analog["a11/b10/c0Pin"].$assign          = "A11/B10/C0";
analog1.analog["a12, c5Pin"].$assign             = "A12, C5";
analog1.analog["a14/b14/c4Pin"].$assign          = "A14/B14/C4";
analog1.analog["a2/b6/c9Pin"].$assign            = "A2/B6/C9";
analog1.analog["a3, c7/b9Pin"].$assign           = "A3, C7/B9";
analog1.analog["a4/b8Pin"].$assign               = "A4/B8";
analog1.analog.a5Pin.$assign                     = "A5";
analog1.analog.a6Pin.$assign                     = "A6";
analog1.analog.a8Pin.$assign                     = "A8";
analog1.analog.a9Pin.$assign                     = "A9";
analog1.analog["b0/c11Pin"].$assign              = "B0/C11";
analog1.analog.b11Pin.$assign                    = "B11";
analog1.analog["b2/c6Pin"].$assign               = "B2/C6";
analog1.analog["b3/vdacPin"].$assign             = "B3/VDAC";
analog1.analog["b4/c8Pin"].$assign               = "B4/C8";
analog1.analog.b5Pin.$assign                     = "B5";
analog1.analog.c1Pin.$assign                     = "C1";
analog1.analog.c14Pin.$assign                    = "C14";
analog1.analog["c2/b12Pin"].$assign              = "C2/B12";
analog1.analog["c3/a7Pin"].$assign               = "C3/A7";

epwm1.$name                  = "EPWM_J4_PHASE_U";
epwm1.epwm.$assign           = "EPWM1";
epwm1.epwm.epwm_aPin.$assign = "GPIO0";
epwm1.epwm.epwm_bPin.$assign = "GPIO1";

epwm2.$name                  = "EPWM_J4_PHASE_V";
epwm2.epwm.$assign           = "EPWM2";
epwm2.epwm.epwm_aPin.$assign = "GPIO2";
epwm2.epwm.epwm_bPin.$assign = "GPIO3";

epwm3.$name                  = "EPWM_J4_PHASE_W";
epwm3.epwm.epwm_aPin.$assign = "GPIO10";
epwm3.epwm.epwm_bPin.$assign = "GPIO11";

epwm4.$name                  = "EPWM_J8_PHASE_U";
epwm4.epwm.$assign           = "EPWM7";
epwm4.epwm.epwm_aPin.$assign = "GPIO12";
epwm4.epwm.epwm_bPin.$assign = "GPIO13";

epwm5.$name                  = "EPWM_J8_PHASE_V";
epwm5.epwm.$assign           = "EPWM4";
epwm5.epwm.epwm_aPin.$assign = "GPIO6";
epwm5.epwm.epwm_bPin.$assign = "GPIO7";

epwm6.$name                  = "EPWM_J8_PHASE_W";
epwm6.epwm.epwm_aPin.$assign = "GPIO16";
epwm6.epwm.epwm_bPin.$assign = "GPIO35/TDI";

eqep1.useCase                    = "CUSTOM";
eqep1.useInterfacePins           = ["EQEP#_A","EQEP#_B","EQEP#_INDEX"];
eqep1.$name                      = "EQEP1_J12";
eqep1.eqep.$assign               = "EQEP1";
eqep1.eqep.eqep_aPin.$assign     = "GPIO40";
eqep1.eqep.eqep_bPin.$assign     = "GPIO41";
eqep1.eqep.eqep_indexPin.$assign = "GPIO59";

eqep2.useCase                    = "CUSTOM";
eqep2.useInterfacePins           = ["EQEP#_A","EQEP#_B","EQEP#_INDEX"];
eqep2.$name                      = "EQEP2_J13";
eqep2.eqep.$assign               = "EQEP2";
eqep2.eqep.eqep_aPin.$assign     = "GPIO14";
eqep2.eqep.eqep_bPin.$assign     = "GPIO55";
eqep2.eqep.eqep_indexPin.$assign = "GPIO57";

gpio1.$name           = "LED_R";
gpio1.direction       = "GPIO_DIR_MODE_OUT";
gpio1.gpioPin.$assign = "B5, GPIO20";

gpio2.$name           = "LED_G";
gpio2.direction       = "GPIO_DIR_MODE_OUT";
gpio2.gpioPin.$assign = "GPIO22";

gpio3.$name           = "ENABLE_GATE";
gpio3.direction       = "GPIO_DIR_MODE_OUT";
gpio3.gpioPin.$assign = "GPIO37/TDO";

gpio4.$name           = "RESET_GATE";
gpio4.direction       = "GPIO_DIR_MODE_OUT";
gpio4.gpioPin.$assign = "GPIO32";

sci1.$name                      = "IRIS_UART_USB";
sci1.selectRegisteredInterrupts = ["registerRxInt"];
sci1.enabledFIFOInterrupts      = ["SCI_INT_RXFF"];
sci1.enabledErrorInterrupts     = ["SCI_INT_FE","SCI_INT_OE"];
sci1.sci.$assign                = "SCIA";
sci1.sci.sci_rxPin.$assign      = "GPIO28";
sci1.sci.sci_txPin.$assign      = "GPIO29";
sci1.rxQual.$name               = "myGPIOQUAL0";
sci1.txQual.$name               = "myGPIOQUAL1";
sci1.sciRXInt.enableInterrupt   = true;

/**
 * Pinmux solution for unlocked pins/peripherals. This ensures that minor changes to the automatic solver in a future
 * version of the tool will not impact the pinmux you originally saw.  These lines can be completely deleted in order to
 * re-solve from scratch.
 */
epwm3.epwm.$suggestSolution = "EPWM6";
epwm6.epwm.$suggestSolution = "EPWM5";
